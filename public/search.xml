<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 5.0中的布局文件onClick回调报错]]></title>
    <url>%2F2018%2F03%2F29%2Fandroid-theme-onclick%2F</url>
    <content type="text"><![CDATA[监听控件的onClick事件有两种方法： 方法1调用控件的setOnClickListener设置监听回调。 123456Button button = (Button) findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; &#125;&#125;); 方法2将回调方法名赋值给布局文件中的onClick属性，然后在Activity中实现该方法。 12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:onClick="onClickButton"/&gt; 12public void onClickButton(View view) &#123;&#125; 但是方法2在5.0上有个坑，如果当前控件的layout的中xml中写了theme属性，那么就会报找不到该方法的错误。如1234567891011&lt;LinearLayout android:layout_width="match_parent" android:layout_height="200dp" android:background="@color/colorPrimary" android:onClick="onClickButton" android:theme="@style/AppTheme.MenuDefaultItem"&gt; &lt;TextView android:text="text" android:layout_width="100dp" android:layout_height="100dp" /&gt;&lt;/LinearLayout&gt; 这是一个LinearLayout嵌套一个TextView，将onClick回调写在LinearLayout里，然后加上一个theme属性，这时点击LinearLayout就会报错。1234567891011121314151617181920212223242526272803-30 08:48:24.060 29147-29147/trendit.com.posusageintro E/AndroidRuntime: FATAL EXCEPTION: main Process: trendit.com.posusageintro, PID: 29147 java.lang.IllegalStateException: Could not find a method onClickButton(View) in the activity class android.view.ContextThemeWrapper for onClick handler on view class android.widget.LinearLayout at android.view.View$1.onClick(View.java:4008) at android.view.View.performClick(View.java:4781) at android.view.View$PerformClick.run(View.java:19874) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:902) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:697) Caused by: java.lang.NoSuchMethodException: onClickButton [class android.view.View] at java.lang.Class.getMethod(Class.java:664) at java.lang.Class.getMethod(Class.java:643) at android.view.View$1.onClick(View.java:4001) at android.view.View.performClick(View.java:4781) at android.view.View$PerformClick.run(View.java:19874) at android.os.Handler.handleCallback(Handler.java:739) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5254) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:902) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:697) StackOverflow上有一段解释，在Android 5.0上的layout布局上，如果应用android:theme属性，就会报这个错误。较老的版本不会有这个问题。解决方法就是要么使用上面的方法1，要么将android:theme应用到application上。1234&lt;application ... android:theme="@android:style/Theme.Holo.Light" ... &gt;]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Ngrok工具的使用]]></title>
    <url>%2F2018%2F03%2F24%2Fngrok-intro%2F</url>
    <content type="text"><![CDATA[最近在本机调试七牛云上传，碰到一个问题。七牛云存储完成上传操作后，会有一个回调操作，告诉服务器上传结果。 https://developer.qiniu.com/kodo/sdk/1289/nodejs1234567var options = &#123; scope: bucket, callbackUrl: 'http://api.example.com/qiniu/upload/callback', callbackBody: 'key=$(key)&amp;hash=$(etag)&amp;bucket=$(bucket)&amp;fsize=$(fsize)&amp;name=$(x:name)'&#125;var putPolicy = new qiniu.rs.PutPolicy(options);var uploadToken=putPolicy.uploadToken(mac); 上面的http://api.example.com就是回调的url，在开发模式下肯定是指向本机的，而不是生产服务器。 因此需要一个内网穿透的工具，在网上找到Ngrok。 Ngrok会生成一个指向你本机服务的隧道，隧道信息，包含一个三级域名（就是上面的回调url），本地端口（就是你的服务运行的端口），协议类型等信息。 隧道有免费的，也有付费的，但免费的貌似不稳定。 然后在server端可以用环境变量区分回调的url。1qiniuCallbackDomain: process.env.NODE_ENV === "production" ? 'http://test.xxx.com' :'http://prod.xx.com', Ngrok支持大部分的平台，我的是windows 64位，下载完客户端，解压，运行Sunny-Ngrok启动工具.bat，填入隧道ID，即可实现外网访问。]]></content>
      <tags>
        <tag>ngrok</tag>
        <tag>nodjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零搭建Android OTA系统——部署到阿里云ECS]]></title>
    <url>%2F2018%2F03%2F20%2Fmy-ota-tutorial-7%2F</url>
    <content type="text"><![CDATA[本文介绍如何将整个ota系统部署到阿里云ECS上去，没有看过正规军是如何部署的，以下只是我的个人经验。 创建远程git目录登陆阿里云ECS，创建一个bare仓库，存放ota_be代码。1git init --bare ~/project/ota_server.git 创建post-receive文件，捕获git推送操作，克隆一份到服务器本地，作为运行仓库。1touch ~/project/ota_server.git/hooks/post-receive 填入如下内容1234567#!/bin/bash -lGIT_REPO=/home/yinlijun/project/ota_server.gitTMP_GIT_CLONE=/home/yinlijun/project/ota_serverrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $&#123;GIT_REPO&#125; $&#123;TMP_GIT_CLONE&#125; 本地部署在本地ota目录下，创建.gitignore文件1echo ota_be_deploy &gt;&gt; .gitignore 这个文件是忽略我们要临时发布目录用的。 创建部署脚本1touch deploy.sh deploy.sh脚本内容：123456789101112131415161718192021222324252627# 构建前端代码cd ota_fe;yarn build;cd ../echo "ota_fe build done..."# 拷贝前端构建结果到后端代码cp ota_fe/build/* ota_be/public/ -rf echo "copy ota_fe build result done..."# 从部署服务器clone一份代码if [ ! -d "ota_be_deploy" ]; then git clone yinlijun@www.yinlijun.com:project/ota_server.git ./ota_be_deploy echo "clone remote ota_server done..."fi# 将后端代码，拷贝到临时目录cp -rf ota_be/* ./ota_be_deploy/echo "copy ota_be done..."# 提交后端代码到远程master分支cd ota_be_deploy; git add .;git commit -m "auto deploy server"; git push origin master;cd ../echo "deploy done..." 运行上述脚本，就会将本地的代码，推送到服务器的仓库上去，同时，因为我们hook了推送操作，就会在服务器上更新运行代码。 启动服务pm2启动服务1pm2 start ~/project/ota_server/bin/www --name "ota-server" 添加nginx代理1touch /etc/nginx/ota.conf 内容如下：12345678910111213server &#123; listen: 80; server_name ota.yinlijun.com; location / &#123; proxy_pass http://127.0.0.1:3020; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &apos;upgrade&apos;; proxy_set_header Host $host proxy_cache_bapass $http_upgrade &#125;&#125; 重启nginx1sudo /etc/init.d/nginx restart 预览http://ota.yinlijun.com/]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>express</tag>
        <tag>react</tag>
        <tag>ECS， nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求头摘要]]></title>
    <url>%2F2018%2F01%2F09%2Fhttp-summery%2F</url>
    <content type="text"><![CDATA[If-Modified-SinceIf-Modified-Since是一个条件式请求首部，服务器只在请求的资源在给定的日期时间之后对内容进行过修改的情况下才会返回，状态码200。如果请求的资源从那时起未经修改，则返回一个不带消息主体的304响应，而在Last-Modified首部中会带有上次修改的时间。 语法：If-Modified-Since: , :: GMT 示例：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT If-Unmodified-Since只有当资源在指定的时间之后没有进行过修改，服务器在返回请求的资源，或是接受POST或其他non-safe方法的请求。如果所请求的资源在指定的时间之后发生的修改，那么会返回412(Proceondition Failed)错误。 常见应用场景： 与non-safe方法如POST搭配使用，可以用来优化并发控制，例如某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其做出的编辑会被拒绝提交。 与含有If-Range消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。 语法：If-Unmodified-Since: , :: GMT 示例：If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT If-None-Match对于GET和HEAD请求来说，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端才会返回所请求的资源，响应码200。对其他方法来说，当且仅当最终确认没有已存在的资源的ETag的属性值与这个首部所列出的相匹配的时候，才会对请求进行相应的处理。 If-RangeIf-Range跟Range一起使用，但字段中的d饿到满足时，Range头字段才会起作用，同时服务器返回(Partial Content)状态码；如果字段值中的条件没有得到满足，服务器返回200状态码，返回完整的请求资源。 字段值中既可以用Last-Modified时间用作验证，也可以用ETag标记作为验证，但不能同时使用。 常见场景：If-Range头字段通常用于断点续传的下载过程中，用来自上次中断后，确保下载的资源没有发生改变。 语法：If-Range: &lt;星期&gt;, &lt;日&gt; &lt;月&gt; &lt;年&gt; &lt;时&gt;:&lt;分&gt;:&lt;秒&gt; GMTIf-Range: 示例：If-Range: Wed, 21 Oct 2015 07:28:00 GMTIf-Range: “675af34563dc-tr34” RangeRange告知服务器返回文件的哪个部分。在一个Range首部中，可以一次性请求多个部分，服务器会以multipart文件的形式返回。如果服务器返回的是范围响应，需要使用206(Partial Content)状态码。加入所请求的范围不合法，那么服务器会返回416（Range Not Satisfiable）状态码，表示客户端错误。服务器允许忽略Range首部，从而返回整个文件，状态码用200。 语法：1234Range: &lt;unit&gt;=&lt;range-start&gt;-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt; 示例：1Range: bytes=200-1000, 2000-6576, 19000- 区别 If-Modified-Since和If-Unmodified-Since If-Mmodified-Since只会出现在GET和HEAD请求中。 If-Modified-Since和If-None-Match If-Modified-Since比If-None-Match优先级要高，但两者都存在时，后者会被忽略，除非服务器不支持If-None-Match 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match]]></content>
  </entry>
  <entry>
    <title><![CDATA[从零搭建Android OTA系统——创建后端项目]]></title>
    <url>%2F2017%2F12%2F20%2Fmy-ota-tutorial-1%2F</url>
    <content type="text"><![CDATA[本文实现简单的服务端的注册，登录功能，暂时不实现前端界面，用curl模拟前端请求。 创建后端项目1express ota_be 目录结构model存放数据库代码，routes存放路由代码，controller存放处理代码，middleware存放中间件代码。123456├─app.js├─config.js├─model/├─routes/├─controller/├─middleware/ 用户注册实现用户集合创建model/user.js，目前只保存username和password，其中username唯一。12345678910111213var mongoose = require('mongoose');var Schema = mongoose.Schema;var UserSchema = new Schema(&#123; username: &#123; type: String, unique: true, &#125;, password: &#123; type: String, &#125;,&#125;)mongoose.model('User', UserSchema); 创建model/index.js，连接数据库。1234567891011121314151617var mongoose = require('mongoose');var config = require('../config');mongoose.connect(config.mongodb, &#123; server: &#123;poolSize: 20&#125;, useMongoClient: true,&#125;, err =&gt; &#123; if(err) &#123; console.error("connect to %s failed", config.mongodb, err .message); process.exit(-1); &#125; &#125;);require('./user');exports.User = mongoose.model('User'); 路由实现创建routes/user.js。这里的路由，都分发到控制器的user实现功能。 12345678var express = require('express');var user = require('../controller/user');var router = express.Router();var passport = require('passport');router.post('/user/register', user.register);module.exports = router; 创建routes/index.js，引入路由文件。1234567var express = require('express');var router = express.Router();var user = require('./user');router.use(user);module.exports = router; 修改app.js 1234var router = require('./routes');var app = express();//...app.use('/', router); 实现注册操作创建controller/user.js。用户密码需要利用bcyptsjs加密，不存储明文密码。 12345678910111213141516171819202122232425262728293031323334var Model = require('../model');var User = Model.User;var bcrypt = require('bcryptjs')validUserRequest = body =&gt; &#123; //TODO 更详细校验 if(!body.username || !body.password) &#123; return &#123;code: -1, message: "valid param"&#125;; &#125; return null;&#125;exports.register = (req, res, next) =&gt; &#123; var error = validUserRequest(req.body); if(error) &#123; res.status(400).send(error); return; &#125; const &#123;username, password&#125; = req.body; bcrypt.hash(password, 10) .then(hash =&gt; &#123; var user = new User(&#123; username: username, password: hash &#125;); return user.save() &#125;) .then(user =&gt; &#123; res.json(&#123;code: 0, message: "create user success"&#125;); &#125;) .catch(err =&gt; &#123; res.status(406).send(&#123;code: -1, message: err.message&#125;); &#125;)&#125; 运行因为用到了mongoose库，需要本地先启用mongod服务，端口需要跟config.js中的一致。config.js12345var config = &#123; mongodb: 'mongodb://127.0.0.1:50000/ota_server',&#125;module.exports = config; 然后启动应用。1yarn start 测试注册接口在终端里面用如下指令模拟注册请求。1234$ curl -d "username=yinlijun&amp;password=123456" "http://127.0.0.1:3020/user/register" % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 75 100 42 100 33 168 132 --:--:-- --:--:-- --:--:-- 168&#123;"code":0,"message":"create user success"&#125; 利用mongo客户端打开集合，查看集合数据，插入成功。12345678910$ mongo mongodb://127.0.0.1:50000MongoDB shell version v3.4.9connecting to: mongodb://127.0.0.1:50000MongoDB server version: 3.4.9$ use ota_serverswitched to db ota_server$ db.users.find()&#123; "_id" : ObjectId("5a3b61b1db2e604ebca6dfc4"), "username" : "yinlijun", "password" : "$2a$10$Zc33sn8Zj1kJslfTTXM0deFNUjVMJyWk.tMsuh.aaLtZEFUSedLQW", "__v" : 0 &#125; 再次注册同名用户，报错。1234$ curl -d "username=yinlijun&amp;password=123456" "http://127.0.0.1:3020/user/register" % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 158 100 125 100 33 1344 354 --:--:-- --:--:-- --:--:-- 1344&#123;"code":-1,"message":"E11000 duplicate key error collection: ota_server.users index: username_1 dup key: &#123; : \"yinlijun\" &#125;"&#125; 用户登录路由实现添加路由routes/user.js1router.post('/user/login', user.login); 实现登录操作在controller/user.js中添加如下代码，校验用户名和密码，校验密码用到了bcrypt.compareSync。 然后生成cookie发到前端。 1234567891011121314151617181920212223242526exports.login = (req, res, next) =&gt; &#123; let &#123;username, password&#125; = req.body; User.findOne(&#123;username: username&#125;) .then(user =&gt; &#123; if(!user) &#123; res.status(400).send(&#123;code: -1, message:"invalid username or password"&#125;); return; &#125; if(!bcrypt.compareSync(password, user.password)) &#123; res.status(400).send(&#123;code: -1, message:"invalid username or password"&#125;); return; &#125; genCookie(user, res); res.send(&#123;code:0, message:"登录成功"&#125;); &#125;)&#125;;genCookie = (user, res) =&gt; &#123; var token = user._id + '$$$'; var opts = &#123; path: '/', maxAge: config.session_age, httpOnly: true, &#125;; res.cookie(config.cookie_name, token);&#125; 这里可以看到有个重复调用的validUserRequest函数，可以做成一个middleware。 创建middleware/validRequest.js。123456789exports.validUsernamePassword = (req, res, next) =&gt; &#123; //TODO 更详细校验 let &#123;username, password&#125; = req.body; if(!username || !password) &#123; res.status(400).send(&#123;code: -1, message: "valid param"&#125;); return; &#125; next();&#125; 然后修改routes/user.js12345var validRequest = require('../middleware/validRequest');router.post('/user/register', validRequest.validUsernamePassword, user.register);router.post('/user/login', validRequest.validUsernamePassword, user.login); 把controller/user.js的register中validUserRequest调用去掉。 测试一下这个middleware：1234 $ curl -d "username=yinlijun&amp;password=" "http://127.0.0.1:3020/user/register" % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 62 100 35 100 27 1093 843 --:--:-- --:--:-- --:--:-- 1093&#123;"code":-1,"message":"valid param"&#125; 测试登录接口输入错误的用户名:1234$ curl -d "username=liudehua&amp;password=123456" "http://127.0.0.1:3020/user/login" % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 85 100 52 100 33 1106 702 --:--:-- --:--:-- --:--:-- 1106&#123;"code":-1,"message":"invalid username or password"&#125; 输入错误密码：1234$ curl -d "username=yinlijun&amp;password=654321" "http://127.0.0.1:3020/user/login" % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 85 100 52 100 33 553 351 --:--:-- --:--:-- --:--:-- 553&#123;"code":-1,"message":"invalid username or password"&#125; 输入正确的用户名密码:1234$ curl -d &quot;username=yinlijun&amp;password=123456&quot; &quot;http://127.0.0.1:3020/user/login&quot; % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 68 100 35 100 33 372 351 --:--:-- --:--:-- --:--:-- 372&#123;&quot;code&quot;:0,&quot;message&quot;:&quot;登录成功&quot;&#125; 利用passport校验登录功能。社区里面有个passport的组件，可以用来实现校验登录功能。 封装passport中间件创建middleware/passport.js，封装passport模块。 将校验密码的操作挪到passport中，校验成功之后用户信息将会保存到req.user。12345678910111213141516171819202122232425262728293031323334353637var passport = require('passport');var User = require('../model').User;var LocalStrategy = require('passport-local').Strategy;passport.use('local.login', new LocalStrategy((username, password, done) =&gt; &#123; User.findOne(&#123;username: username&#125;) .exec() .then(user =&gt; &#123; if(!user) &#123; return done(null, false, &#123;code: -1, message: "invalid username or password"&#125;); &#125; if(!user.validPassword(password)) &#123; return done(null, false, &#123;code: -1, message: "invalid username or password"&#125;); &#125; return done(null, user); &#125;) .catch(err =&gt; &#123; done(null, false, &#123;code: -1, message: err.message&#125;); &#125;)&#125;))passport.serializeUser((user, done) =&gt; &#123; done(null, user._id);&#125;);passport.deserializeUser((id, done) =&gt; &#123; User.findById(id) .exec() .then(user =&gt; &#123; done(null, user); &#125;) .catch(err =&gt; &#123; done(null, false, &#123;code: -1, message: err.message&#125;); &#125;)&#125;)module.exports = passport; 重新实现登录操作修改controller/user.js的login函数，去掉验证用户名密码的代码。12345exports.login = (req, res, next) =&gt; &#123; const user = req.user; genCookie(user, res); res.send(&#123;code:0, message:"login success"&#125;);&#125;; 在middleware/validRequest.js添加一个校验中间件12345exports.validByPassport = (req, res, next) =&gt; &#123; passport.authenticate('local.login', &#123; failureMessage: 'invalid username or password', &#125;)(req, res, next);&#125; 修改路由修改router/user.js路由1router.post('/user/login', validRequest.validByPassport, user.login); 这样，用户登录就会走passport的校验流程。 退出功能主要是清除cookie，controller/user.js中添加代码。12345678exports.logout = (req, res, next) =&gt; &#123; clearCookie(res); res.send(&#123;code:0, message:"exit success"&#125;);&#125;clearCookie = (res) =&gt; &#123; res.clearCookie(config.cookie_name, &#123;path: '/'&#125;);&#125; 测试1234$ curl &quot;http://127.0.0.1:3020/user/logout&quot; % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 35 100 35 0 0 2187 0 --:--:-- --:--:-- --:--:-- 2187&#123;&quot;code&quot;:0,&quot;message&quot;:&quot;exit success&quot;&#125;]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>express</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零搭建Android OTA系统——创建后端项目]]></title>
    <url>%2F2017%2F12%2F20%2Fmy-ota-tutorial%2F</url>
    <content type="text"><![CDATA[起因作为一个半路出家的码农，一个野生Android工程师，一直对全栈心怀憧憬，但未有行动。直到两年之前有机会开始接触javascript，写了一些前端的代码，加上nodejs社区这些年的蓬勃发展，我觉得这是一个机会。正如某位长者教导的: 人的一生当然要靠自我奋斗,当然也要考虑历史的进程。 我觉得是时候了。 这是一个完整的项目，也许耗时会比较长，因为上班时间还有工作要完成，但是我会尽力完成它，我的目标是达到可以商用的水平，而不是一个玩具。实现的过程的文章会贴在本站，代码将会托管到github android ota system。 目标到这个项目完结的时候，能实现如下功能。 服务端 版本管理后台 用户管理后台 PC端 版本管理界面 用户操作界面 Android端 查询版本 下载版本 升级版本 我的技术背景语言方面 javascript 熟练度 30% 框架 nodejs 熟练度 5% react 熟练度 10% 会使用到的库 react express 目录 用户注册登录的后台实现 Android OTA部署到阿里云ECS]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>express</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署HEXO博客到阿里云ECS]]></title>
    <url>%2F2017%2F12%2F18%2Fhexo-to-ali-ecs%2F</url>
    <content type="text"><![CDATA[本文假设你具备如下条件： 熟悉hexo操作 熟悉linux基本指令 熟悉express(nodejs)框架 在github上已经部署了hexo博客 ECS准备购买ECS前往阿里云购买ECS，根据个人需要和财务状况，选择对应规模的ECS。我购买的是这个配置，费用是330.00¥。 配置ECS购买之后，可以远程登录ECS实例，可以选择网页登录，即点击上图的远程连接，此时需要输入远程连接密码。这个密码在创建ECS实例的时候会提供给你，点击确认之后，就可以登录root用户。 我的本地是ubuntu系统，所以可以利用ssh登录。1ssh root@xx.xx.xx.xx 登录之后，创建一个非root用户。1adduser yinlijun 切换到该用户1su yinlijun 上传本地公钥，方便部署。1ssh-copy-id -i ~/.ssh/id_rsa.pub yinlijun@xx.xx.xx.xx 如果需要绑定域名，还需要如下申请域名和备案： 购买域名前往阿里域名服务选购域名。 域名备案前往备案专区，进行备案，需要时间比较长，我花了12天，备案完成后，阿里云会给你的ECS续费，续费的天数就是你的备案花的天数。期间要填写资料，上传备案照片等等。 备案完成之后，需要设置域名解析。上图的记录值，填写你的ECS的公网IP。 在ECS上创建hexo仓库1git init --bare ~/project/hexo.git 捕获post操作1touch ~/project/hexo.git/hooks/post-receive 输入如下内容 123456789#!/bin/bash -lGIT_REPO=&lt;到hexo.git的目录&gt;TMP_GIT_CLONE=&lt;到临时blog的目录&gt;PUBLIC_WWW=&lt;到blog服务的目录/public/blog&gt;rm -rf $&#123;TMP_GIT_CLONE&#125;git clone $&#123;GIT_REPO&#125; $&#123;TMP_GIT_CLONE&#125;rm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 本地blog(express)服务新建express服务1express blog-server 修改app.js，配置静态文件目录1app.use(express.static(path.join(__dirname, 'public/blog/'))); 启动blog服务1pm2 start bin/www 安装nginx，反向代理二级域名通过域名访问默认的80端口，blog默认监听3000端口，因此需要配置代理。创建blog.conf配置文件1touch /etc/nginx/conf.d/blog.conf 输入如下内容12345678910111213server &#123; listen 80; server_name yinlijun.com www.yinlijun.com bloc.yinlijun.com; location / &#123; proxy_pass http://127.0.0.1:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &apos;upgrade&apos;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125;&#125; 本地操作把github上的blog目录clone下来1git clone git@github.com:yinlijun2004/johnny-blog.git 如果你原来没有在github上部署hexo博客，也可以用hexo新建一个，然后托管到某个git仓库。 修改_config.yml配置1234deploy: type: git repo: yinlijun@www.yinlijun.com:project/hexo.git branch: master 发布博客撰写好博客后，如下命令部署。123hexo cleanhexo ghexo d 最终效果www.yinlijun.com 有可能碰到的问题外网无法访问端口需要配置安全组规则。上图是默认开通的端口，如果你的端口不在里面，则需要自行添加安全组规则。 hexo deploy之后没有反应 检查有没有上传本机公钥 检查hexo.git仓库的路径是否正确 检查备案的域名是否能正常访问]]></content>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin惯用法]]></title>
    <url>%2F2017%2F05%2F26%2Fkotlin%E6%83%AF%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[kotlin提供了一些惯用法（语法糖？），简单的记录一下。 data class有时候需要一些类要保存数据，而不需要其他操作，当然基本操作除外，kotlin为data class提供的基本操作有： equals() 相当与“==”操作 hashCode() 计算hash值 toString() 函数 componentsN() 函数 copy() 拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960data class User(val name: String = "nobody", val age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; //默认参数 val nobody = User() //User(name=nobody, age=0) println(nobody) val johnny = User("Johnny", 29) //解构赋值 val (name, age) = johnny //name: Johnny, age: 29 println("name: $name, age: $age") //toString用法 //User(name=Johnny, age=29) println(johnny) //hashCode用法 //233064103 println(johnny.hashCode()) //"==" 和"===" //true println("johnny == johnny $&#123;johnny == johnny&#125;") //true println("johnny === johnny $&#123;johnny === johnny&#125;") //copy用法 val youngJohnny = johnny.copy(age = 2) //"User(name=Johnny, age=2)" println(youngJohnny) //false println("johnny == youngJohnny $&#123;johnny == youngJohnny&#125;") //false println("johnny === youngJohnny $&#123;johnny === youngJohnny&#125;") //false println("johnny.hashCode() == yongJohnny.hashCode() $&#123;johnny.hashCode() == youngJohnny.hashCode()&#125;") val copyJohnny = johnny.copy() //true println("johnny == copyJohnny $&#123;johnny == copyJohnny&#125;") //false println("johnny === copyJohnny $&#123;johnny === copyJohnny&#125;") //true println("johnny.equals(copyJohnny) $&#123;johnny.equals(copyJohnny)&#125;") //true println("johnny.hashCode() == copyJohnny.hashCode() $&#123;johnny.hashCode() == copyJohnny.hashCode()&#125;") val anotherJohnny = User("Johnny", 29) //true println("johnny == anotherJohnny $&#123;johnny == anotherJohnny&#125;") //false println("johnny === anotherJohnny $&#123;johnny === anotherJohnny&#125;") //true println("johnny.equals(anotherJohnny) $&#123;johnny.equals(anotherJohnny)&#125;") //true println("johnny.hashCode() == anotherJohnny.hashCode() $&#123;johnny.hashCode() == anotherJohnny.hashCode()&#125;")&#125; 函数(包括构造函数)的默认值如上例的1data class User(val name: String = "nobody", val age: Int = 0) 对于普通函数1fun foo(a: Int = 0, b: String = "") &#123; ... &#125; 有了默认的参数，就可以避免写多个重载函数如下面的java代码123456789101112public String foo(String name, int number, boolean toUpperCase) &#123; return (toUpperCase ? name.toUpperCase() : name) + number;&#125;public String foo(String name, int number) &#123; return foo(name, number, false);&#125;public String foo(String name, boolean toUpperCase) &#123; return foo(name, 42, toUpperCase);&#125;public String foo(String name) &#123; return foo(name, 42);&#125; 可以用一个kotlin函数表示12fun foo(name: String, number: Int = 42, toUpperCase: Boolean = false) = (if (toUpperCase) name.toUpperCase() else name) + number 过滤list1val positives = list.filter &#123; x =&gt; x &gt; 0&#125; 甚至可以更简洁一点1val positives = list.filter &#123; it &gt; 0 &#125; 字符串模板1println("Name $name") 类型检查12345when (x) &#123; is Foo -&gt; ... is Bar -&gt; ... else -&gt; ...&#125; 遍历集合123for ((k, v) in map) &#123; println("$k -&gt; $v")&#125; 使用范围（Ranges）12345for (i in 1..100) &#123; ... &#125; // 闭区间包含100for (i in 1 until 100) &#123; ... &#125; // 半开区间，不包含100for (x in 2..10 step 2) &#123; ... &#125; for (x in 10 downTo 1) &#123; ... &#125;if (x in 1..10) &#123; ... &#125; 构造只读列表1val list = listOf("a", "b", "c") 构造只读map1val map = mapOf("a" to 1, "b" to 2, "c" to 3) 访问map12println(map["key"])map["key"] = value 延迟加载123val p: String by lazy &#123; // compute the string&#125; 函数扩展123fun String.spaceToCamelCase() &#123; ... &#125;"Convert this to camelcase".spaceToCamelCase() 创建单例1234567891011121314151617object Resource &#123; var name = "Name"&#125;fun main(args: Array&lt;String&gt;) &#123; var rs = Resource; //Name println(rs.name) var rs2 = Resource; //Name println(rs2.name) rs.name = "Anthoer" //Another println(rs.name) //Another println(rs2.name)&#125; 判断null?.123val files = File("Test").listFiles()println(files?.size) 例如：123456789101112fun getList(isNull: Boolean): List&lt;String&gt;? = if(isNull) null else listOf("a", "b", "c")fun main(args: Array&lt;String&gt;) &#123; var list = getList(true) //"null" println(list?.size) list = getList(false) //"3" println(list?.size)&#125; ?. 可以执行语句块val data = … data?.let { … // execute this block if not null} ?:上述println语句可以改为1println(list?.size ?: "empty" ) 这打印结果如下12empty3 ?: 后面的字符串也可以换成表达式12val data = ...val email = data["email"] ?: throw IllegalStateException("Email is missing!") 返回when语句12345678fun transform(color: String): Int &#123; return when (color) &#123; "Red" -&gt; 0 "Green" -&gt; 1 "Blue" -&gt; 2 else -&gt; throw IllegalArgumentException("Invalid color param value") &#125;&#125; ‘try/catch’ 表达式123456789fun test() &#123; val result = try &#123; count() &#125; catch (e: ArithmeticException) &#123; throw IllegalStateException(e) &#125; // result是count()返回值&#125; ‘if’表达式123456789fun foo(param: Int) &#123; val result = if (param == 1) &#123; "one" &#125; else if (param == 2) &#123; "two" &#125; else &#123; "three" &#125;&#125; 表达式函数1fun theAnswer() = 42 等于如下函数123fun theAnswer(): Int &#123; return 42&#125; 表达式函数可以很方便的和其他惯用法结合在一起使用123456fun transform(color: String): Int = when (color) &#123; "Red" -&gt; 0 "Green" -&gt; 1 "Blue" -&gt; 2 else -&gt; throw IllegalArgumentException("Invalid color param value")&#125; with语句（ES6不是快废除这个了？）with语句块的函数都是对()括号内的对象的方法调用。12345678910111213141516class Turtle &#123; fun penDown() fun penUp() fun turn(degrees: Double) fun forward(pixels: Double)&#125;val myTurtle = Turtle()with(myTurtle) &#123; //draw a 100 pix square penDown() for(i in 1..4) &#123; forward(100.0) turn(90.0) &#125; penUp()&#125; nullable的Boolean对象123456val b: Boolean? = ...if (b == true) &#123; ...&#125; else &#123; // `b` 为false或者null&#125;]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin初探]]></title>
    <url>%2F2017%2F05%2F25%2Fkotlin-sample%2F</url>
    <content type="text"><![CDATA[最近google推出了新的Android开发语言kotlin，花了点时间了解一下皮毛。 在kotlin官网上的资料还是比较丰富的，提供了一个在线的编辑器，可以写一些小的程序片段。另外提供了一个代码翻译的工具，可以直接将java代码片段翻译成kotlin。 例如以下java代码：12345678910111213 class Greeting &#123; private String greeting; public Greeting(String g) &#123; greeting = g; &#125; public void sayHello(String you) &#123; System.out.println(greeting + " " + you); &#125; public static void main(String[] argv) &#123; Greeting greeting = new Greeting("Hello"); greeting.sayHello(argv[0]); &#125;&#125; 对应的kotlin代码如下：123456789101112131415internal class Greeting(g:String) &#123; private val greeting:String init&#123; greeting = g &#125; fun sayHello(you:String) &#123; println(greeting + " " + you) &#125; companion object &#123; @JvmStatic fun main(argv:Array&lt;String&gt;) &#123; val greeting = Greeting("Hello") greeting.sayHello(argv[0]) &#125; &#125;&#125; 语法kotlin语法很多特性都有javascript ES6的影子，比如字符串模板，解构赋值，箭头函数，元编程。 包定义。包定义必需位于源文件的顶端，格式如下12345package my.demoimport java.util.*// ... 这个跟java是一样的。 函数定义两个Int类型参数的求和函数123fun sum(a: Int, b: Int): Int &#123; return a + b&#125; 上面的函数可以有更简单的表达式写法 定义表达式函数可以看出表达式函数的返回值是自动推断的。1fun sum(a: Int, b: Int) = a + b 定义空返回值函数123fun printSum(a: Int, b: Int): Unit &#123; println("sum of $a and $b is $&#123;a + b&#125;")&#125; 其中Unit可以省略123fun printSum(a: Int, b: Int): &#123; println("sum of $a and $b is $&#123;a + b&#125;")&#125; 参见函数 局部变量定义常量（只允许赋值一次）1234val a: Int = 1 // 立即赋值val b = 2 // 类型推断，为`Int`val c: Int // 如果没有给出初始化的值，需要给出变量类型c = 3 // 延迟赋值 定义变量12var x = 5 // 类型推断x += 1 参见属性和域 注释kotlin的注释跟java是一样的，支持行和块两种注释方式：1234// This is an end-of-line comment/* This is a block comment on multiple lines. */ 跟java不一样的是，kotlin的块注释是可以嵌套的。1234567/* *This is a block comment * on multiple lines /* This is a nested block comment.*/ *This is a block comment * on multiple lines */ 参见注释 字符串模板1234567var a = 1// 简单的字符串模板：val s1 = "a is $a" a = 2// 任意表达式的模板：val s2 = "$&#123;s1.replace("is", "was")&#125;, but now is $a" 参见字符串模板 条件表达式kotlin没有三目运算符，取而代之的是条件表达式。 例如一个常规的求最大值函数1234567fun maxOf(a: Int, b: Int): Int &#123; if(a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 假如用条件表达式可以这样写1fun maxOf(a: Int, b: Int) = if(a &gt; b) a else b 参见if表达式 使用nullable和判断null如果一个值可能是null的话必须显示的标记出来，如如果str转换成Int失败，返回null:123fun parseInt(str: String): Int? &#123; //...&#125; 使用返回nullable的函数。123456789fun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2) if(x != null &amp;&amp; y != null) &#123; println(x * y) &#125; else &#123; println("'$arg1' 或者 '$arg2' 不是数字") &#125;&#125; 参见安全的null 类型检查和自动转换这个操作用来检查一个对象的类型，局部变量或者属性经过判断之后，不用再显示的转换了，例如。 12345678fun getStringLength(obj: Any): Int? &#123; if(obj is String) &#123; //obj在这个分支内自动转为"String"类型 return obj.length &#125; //在上面的类型检查分支之外，类型仍然为"Any" return null&#125; 另一种方式123456fun getStringLength(obj: Any): Int? &#123; if(obj !is String) &#123; return null &#125; return obj.length&#125; 甚至可以这样1234567fun getStringLength(obj: Any): Int? &#123; //obj在&amp;&amp;右侧自动转换为String类型 if(obj is String &amp;&amp; obj.length &gt; 0) &#123; return obj.length &#125; return null&#125; 参见类和类型转换 for循环1234val items = listOf("apple", "banana", "kiwi")for(item in items) &#123; println(item)&#125; 或者1234val items = listOf("apple", "banana", "kiwi")for(i in items.indices) &#123; println("item at $i is $&#123;item[i]&#125;")&#125; 参见for循环 while循环123456val items = listOf("apple", "banana", "kiwi")var i = 0while(i &lt; items.size) &#123; println("item at $i is $&#123;item[i]&#125;") i++&#125; 参见while循环 when表达式when通常用来代替switch和多个if else，且功能强大的多。如12345678fun describe(obj: Any): String = when(obj) &#123; 1 -&gt; "One" "Hello" -&gt; "Greeting" is Long -&gt; "Long" !is String -&gt; "Not a String" else -&gt; "Unknow"&#125; 参见when表达式 使用范围表达式(..)用in运算符检查一个数字是否在一个范围内。123456val x = 10val y = 9//这是个闭区间,1和y+1都算进去。if(x in 1..y+1) &#123; println("fits in range")&#125; 检查一个数字是否超出范围1234567val list = listOf("a", "b", "c")if(-1 !in 0..list.lastIndex) &#123; println("-1 is out of range")&#125; if(list.size !is list.indices) &#123; println("list size is out of valid list indices range too")&#125; 遍历一个范围123for(x in 1..5) &#123; print(x)&#125; 使用步进遍历范围123456for(x in 1..10 step 2) &#123; print(x)&#125;for(x in 9 downTo 0 step 3) &#123; print(x)&#125; 参见范围 集合遍历一个集合123for (item in items) &#123; println(item)&#125; 使用in操作判断集合是否含有某元素，如1234567fun main(args: Array&lt;String&gt;) &#123; val items = setOf("apple", "banana", "kiwi") when &#123; "orange" in items -&gt; println("juicy") "apple" in items -&gt; println("apple is fine too") &#125;&#125; 上述代码输出1apple is fine too 使用lambda表达式过滤map集合12345678fun main(args: Array&lt;String&gt;) &#123; val fruits = listOf("banana", "avocado", "apple", "kiwi") fruits .filter &#123; it.startsWith("a") &#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;&#125; 上述代码输出12APPLEAVOCADO 参见高阶函数和lambda 习题数组求和12345678910111213/* * Your task is to implement the sum() function so that it computes the sum of * all elements in the given array a. */package sumfun sum(a: IntArray): Int &#123; var s = 0 for(n in a) &#123; s += n &#125; return s&#125; 求数组最大值索引1234567891011121314151617181920/* * Your task is to implement the indexOfMax() function so that it returns * the index of the largest element in the array, or null if the array is empty. */package maxindexfun indexOfMax(a: IntArray): Int? &#123; if(a.size == 0) &#123; return null &#125; var m = Integer.MIN_VALUE var ret = -1 for(i in a.indices) &#123; if(a[i] &gt;= m) &#123; m = a[i] ret = i; &#125; &#125; return ret&#125; 这是求个什么？自己看解释吧12345678910111213141516171819202122232425262728/* * Any array may be viewed as a number of "runs" of equal numbers. * For example, the following array has two runs: * 1, 1, 1, 2, 2 * Three 1's in a row form the first run, and two 2's form the second. * This array has two runs of length one: * 3, 4 * And this one has five runs: * 1, 0, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0 * Your task is to implement the runs() function so that it returns the number * of runs in the given array. */package runsfun runs(a: IntArray): Int &#123; if(a.size == 0) &#123; return 0 &#125; var ret = 1 var cur = a[0] for(n in a) &#123; if(n != cur) &#123; ++ret cur = n &#125; &#125; return ret&#125; 求是否是回文字符串12345678910111213141516171819202122/* * Your task is to implement a palindrome test. * * A string is called a palindrome when it reads the same way left-to-right * and right-to-left. * * See http://en.wikipedia.org/wiki/Palindrome */package palindromefun isPalindrome(s: String): Boolean &#123; if(s.length &lt; 2) &#123; return true &#125; var len = s.length / 2 for(i in 0..len - 1) &#123; if(s[i] != s[s.length - i - 1]) &#123; return false &#125; &#125; return true&#125; 求落单数字12345678910111213141516171819202122232425262728293031323334/* * Think of a perfect world where everybody has a soulmate. * Now, the real world is imperfect: there is exactly one number in the array * that does not have a pair. A pair is an element with the same value. * For example in this array: * 1, 2, 1, 2 * every number has a pair, but in this one: * 1, 1, 1 * one of the ones is lonely. * * Your task is to implement the findPairless() function so that it finds the * lonely number and returns it. * * A hint: there's a solution that looks at each element only once and uses no * data structures like collections or trees. */package pairlessfun findPairless(a: IntArray): Int &#123; // Write your solution here var map = hashMapOf&lt;Int, Int&gt;(); for(n in a) &#123; var i = map.get(n) map.put(n, if(i == null) 1 else i + 1) &#125; for((k, v) in map) &#123; if(v % 2 == 1) &#123; return k &#125; &#125; return 0&#125;]]></content>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NavigationPrompt-react router 4.0.0 api中文文档]]></title>
    <url>%2F2016%2F12%2F02%2Freact-router-4-0-0-api-NavigationPrompt%2F</url>
    <content type="text"><![CDATA[&lt;NavigationPrompt&gt; 当你的应用进入一个状态，但是需要防止用户从当前状态离开时（比如填了一半的表单），渲染出一个导航确认（NavigationPrompt）。123&#123;formIsHalfFilledOut &amp;&amp; ( &lt;NavigationPrompt message=&quot;Are you sure you want to leave?&quot;/&gt;)&#125; message: string 当用户试图从当前状态离开时显示的信息。1&lt;NavigationPrompt message=&quot;Are you sure you want to leave?&quot;/&gt; message: func这个函数返回一个提示用户跳转的信息，如果返回true，则允许跳转，函数的参数是用户将要跳转的下一个链接，123&lt;NavigationPrompt message=&#123;(location) =&gt; ( `Are you sure you want to go to $&#123;location.pathname&#125;?`)&#125;/&gt; when: boolwhen是一个逻辑变量，为true时，将显示message内容的弹窗，为false时，直接跳转。 &lt;/NavigationPrompt&gt;]]></content>
      <categories>
        <category>react router 4.0.0 api中文文档</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link-react router 4.0.0 api中文文档]]></title>
    <url>%2F2016%2F11%2F29%2Freact-router-4-0-0-api-Link%2F</url>
    <content type="text"><![CDATA[原文链接 &lt;Link&gt; 为你的应用提供可以声明的，可访问的导航功能。123&lt;Link to="/about" activeClassName="active"&gt; About&lt;/Link&gt; children: node | func Link组件可以接受一个函数作为子控件，使得允许你使用自定义的组件渲染Link对象。 子控件函数的参数是一个对象，包含如下属性： isActive: (bool) 当前链接是否激活 location: 传递给Link的链接 href: (string) 路由的url onClick: (func) dom的onClick处理函数 transition: (func) 它是router.transitionTo的快捷方式，代表Link对象的to属性。1234&lt;Link to="/courses"&gt;&#123; (&#123;isActive, location, href, onClick, transition&#125;) =&gt; &lt;RaisedButton label="Courses" onClick=&#123;onClick&#125; primary=&#123;isActive&#125; href=&#123;href&#125; /&gt;&#125;&lt;/Link&gt; to: string | object 链接的描述。123456&lt;Link to=&quot;/courses&quot;/&gt;&lt;Link to=&#123;&#123; pathname: &apos;/courses&apos;, query: &#123; sort: &apos;name&apos; &#125;, state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt; activeStyle: object 当链接匹配到to属性时的样式对象。它会和tyle对象合并之后生效。12345678&lt;Link to=&quot;/courses&quot; style=&#123;&#123; color: &apos;blue&apos;, background: &apos;gray&apos; &#125;&#125; activeStyle=&#123;&#123; color: &apos;red&apos; &#125;&#125;/&gt;// 总是有灰色背景// 链接为/foo时字体为blue// 为/courses为red(激活状态) activeClassName: string 当匹配到链接时，生效的className。1234567&lt;Link to="/courses" className="course-link" activeClassName="active"/&gt;// will always have "course-link"// at /courses it will be "course-link active" activeOnlyWhenExact: bool 为true时, 只有当严格匹配，activeClassName和activeStyle才会生效。 123&lt;Link to=&quot;/courses&quot; activeOnlyWhenExact activeClassName=&quot;active&quot;/&gt;// /courses 被激活// /courses/123 不被激活 isActive: func 允许自定义当前链接是否被激活，激活时返回true，否则返回false。12345678910111213141516171819&lt;Link to="/" activeStyle=&#123;&#123; color: 'red' &#125;&#125; isActive=&#123;(location) =&gt; ( // 只有当没有query字段时被激活 !Object.keys(location.query).length )&#125;/&gt;&lt;Link to="/courses" activeStyle=&#123;&#123; color: 'red' &#125;&#125; isActive=&#123;(location, props) =&gt; ( // 匹配到"/courses" 或者 "/course/123"被激活 // 尽管这不是真正意义上的被激活, it is // theoretically for the sake of a navigation menu location.pathname.match(/course(s)?/) )&#125;/&gt; location 如果你不想使用上下文中的location, 可以传递一个location的属性作为替代，这在链接比较深的redux应用中很有用。1&lt;Match pattern=&quot;/foo&quot; location=&#123;this.props.location&#125;/&gt; &lt;/Link&gt;]]></content>
      <categories>
        <category>react router 4.0.0 api中文文档</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miss-react router 4.0.0 api中文文档]]></title>
    <url>%2F2016%2F11%2F29%2Freact-router-4-0-0-api-Miss%2F</url>
    <content type="text"><![CDATA[原文链接 &lt;Miss&gt; 当没有匹配到当前的地址时，将会渲染Miss。1234567891011const App = () =&gt; ( &lt;Router&gt; &lt;Match pattern="/foo"/&gt; &lt;Match pattern="/bar"/&gt; &lt;Miss component=&#123;NoMatch&#125;/&gt; &lt;/Router&gt;)const NoMatch = (&#123; location &#125;) =&gt; ( &lt;div&gt;Nothing matched &#123;location.pathname&#125;.&lt;/div&gt;) component跟Match一样的，表示将要渲染的组建，但是不同的是只有location一个prop传进去。1&lt;Miss component=&#123;NoMatch&#125;/&gt; render: func跟Match一样的，可以提供一个渲染函数，同样，也只有location一个prop传进去。123&lt;Miss render=&#123;(&#123; location &#125;) =&gt; ( &lt;div&gt;Nothing matched &#123;location.pathname&#125;.&lt;/div&gt;)&#125;/&gt; &lt;/Miss&gt;]]></content>
      <categories>
        <category>react router 4.0.0 api中文文档</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 /dev/kvm is not found 的问题]]></title>
    <url>%2F2016%2F11%2F28%2Ffix-dev-kvm-is-not-found%2F</url>
    <content type="text"><![CDATA[问题出现环境 Ubuntu 12.04 Android Studio 2.2.2 解决步骤开启VT-x在ubuntu上使用Android Studio创建模拟器时，会提示一个错误：1/dev/kvm is not found 并且提示要在BIOS里面开启VT-x。 重启电脑，按DEL键进入BIOS,发现确实没有启用，于是启用后再此重启电脑。 此时打开Android Studio，仍然提示一样的错误。 再次在网上搜寻，发现如下解决方案，记录一下。 http://askubuntu.com/questions/600727/replacement-for-haxm-on-ubuntu-says-intel-x86-emulator-accelerator-is-not-comp ###Check if your CPU supports hardware virtualization, by typing:1egrep -c &apos;(vmx|svm)&apos; /proc/cpuinfo If the result is 0, your CPU does not support hardware virtualization, which is necessary to run the KVM. If you get 1 or more, that means you’re fine. Next, install KVM. First make sure if your processor supports KVM by typing:1kvm-ok You will see this if that’s the case: INFO: Your CPU supports KVM extensions INFO: /dev/kvm exists KVM acceleration can be usedIf this is the result, you need to turn on Intel VT in BIOS: INFO: KVM is disabled by your BIOS HINT: Enter your BIOS setup and enable Virtualization Technology (VT), and then hard poweroff/poweron your system KVM acceleration can NOT be usedThe next step is to install the KVM and a few other packages needed. To do so, type:1sudo apt-get install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils Add your user to some groups, replacing by your own username:12sudo adduser &lt;user&gt; libvirtdsudo adduser &lt;user&gt; kvm Check if everything is ok:1sudo virsh -c qemu:///system list]]></content>
      <tags>
        <tag>android studio</tag>
        <tag>android</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https双向验证功能的实现]]></title>
    <url>%2F2016%2F11%2F28%2Fandroid-https-verify-ways%2F</url>
    <content type="text"><![CDATA[本文介绍一个简单echo服务器的实现，服务端用nodejs，客户端用android。 用openssl一系列证书生成自己的CA根证书生成跟证书私钥ca.key1$ openssl genrsa -des3 -out ca.key 1024 生成X.509证书签名请求文件ca.csr在生成ca.csr的过程中，会让输入一些组织信息等。1$ openssl req -new -key ca.key -out ca.csr 输出如下1234567891011121314151617181920Enter pass phrase for ca.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangDongLocality Name (eg, city) []:ShenZhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:IBoxPayOrganizational Unit Name (eg, section) []:IBoxPayCommon Name (e.g. server FQDN or YOUR name) []:Email Address []:admin@iboxpay.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []: 生成X.509格式的CA根证书ca.crt1$ openssl x509 -req -days 365 -in ca.csr -out ca.crt -signkey ca.key 输出如下1234Signature oksubject=/C=CN/ST=GuangDong/L=ShenZhen/O=IBoxPay/OU=IBoxPay/emailAddress=admin@iboxpay.comGetting Private keyEnter pass phrase for ca.key: 生成服务端的证书生成服务端私钥文件 server.key1$ openssl genrsa -des3 -out server.key 1024 服务端需要向CA机构申请签名证书，在申请签名证书之前依然是创建自己的证书签名请求文件server.csr这一步需要填写一个组织信息，不要跟根证书的组织的一样。另外Common Name填一个自己的域名（如果没有实际的域名也可以写，后面在/etc/hosts映射一个，我写的就是yinlijun.com），不要填localhost，android会报错。1openssl req -new -key server.key -out server.csr 输出如下12345678910111213141516171819Enter pass phrase for server.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangDongLocality Name (eg, city) []:ShenZhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:yinlijunOrganizational Unit Name (eg, section) []:yinlijunCommon Name (e.g. server FQDN or YOUR name) []:yinlijun.comEmail Address []:admin@yinlijun.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []: 删除私钥的密码，这一步非常重要，一定要执行,否则会影响后面的步骤。12$ cp server.key server.key.passphrase$ openssl rsa -in server.key.passphrase -out server.key 输出如下12Enter pass phrase for server.key.passphrase:writing RSA key 签发服务器证书server.crt：1openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 输出如下：123Signature oksubject=/C=CN/ST=GuangDong/L=ShenZhen/O=yinlijun/OU=yinlijun/CN=yinlijun.com/emailAddress=admin@yinlijun.comGetting Private key 到现在为止，你目录下的文件应该有：1234567891011ls -latotal 36drwxr-xr-x 2 user user 4096 Sep 5 16:19 .drwxr-xr-x 12 user user 4096 Sep 5 16:09 ..-rw-r--r-- 1 user user 757 Sep 5 16:12 ca.crt-rw-r--r-- 1 user user 603 Sep 5 16:10 ca.csr-rw-r--r-- 1 user user 963 Sep 5 16:09 ca.key-rw-r--r-- 1 user user 757 Sep 5 16:19 server.crt-rw-r--r-- 1 user user 603 Sep 5 16:16 server.csr-rw-r--r-- 1 user user 887 Sep 5 16:18 server.key-rw-r--r-- 1 user user 951 Sep 5 16:17 server.key.passphrase 生成之后察看服务器证书信息。1openssl x509 -in server.crt -text -noout 生成服务器的pfx文件，这个文件node服务器要用到。1openssl pkcs12 -export -in server.crt -inkey server.key -certfile ca.crt -out server.pfx 输出如下12Enter Export Password:Verifying - Enter Export Password: 生成服务端的p12文件。，这个是为了生成服务端bks文件用的1openssl pkcs12 -export -clcerts -in server.crt -inkey server.key -out server.p12 下载一个bcprov-jdk16-141.jar，也是为了生成服务端bks文件要用到的。1下载地址：[http://www.java2s.com/Code/JarDownload/bcprov/bcprov-jdk16-141.jar.zip](http://www.java2s.com/Code/JarDownload/bcprov/bcprov-jdk16-141.jar.zip) 生成服务端的bks文件，这个android程序要用到1keytool -importkeystore -srckeystore server.p12 -srcstoretype pkcs12 -destkeystore server.bks -deststoretype bks -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-jdk16-141.jar 输出如下12345输入目标密钥库口令: 再次输入新密码: 输入源密钥库口令: 已成功导入别名 1 项。已完成导入命令: 1 项成功导入，0 项失败或取消 因为要进行双向验证，还需要生成客户端证书。 生成客户端密钥1openssl genrsa -des3 -out client.key 1024 生成客户端证书请求签名文件1openssl req -new -out client.csr -key client.key 输出如下1234567891011121314151617181920Enter pass phrase for client.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:GuangDong Locality Name (eg, city) []:ShenZhenOrganization Name (eg, company) [Internet Widgits Pty Ltd]:ruochenOrganizational Unit Name (eg, section) []:ruochenCommon Name (e.g. server FQDN or YOUR name) []:Email Address []:admin@ruochen.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []: 创建一个自当前日期起有效期为十年的客户端证书，需要根证书和根密钥参与。1openssl x509 -req -in client.csr -out client.cert -signkey client.key -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 输入如下123456789101112Signature oksubject=/C=CN/ST=GuangDong/L=ShenZhen/O=ruochen/OU=ruochen/emailAddress=admin@ruochen.comGetting Private keyEnter pass phrase for client.key:Getting CA Private KeyEnter pass phrase for ca.key:yinlijun@yinlijun:~/personal_github/echo-https-server/keys$ lsca.crt ca.csr ca.key ca.srl client.cert client.csr client.key server.crt server.csr server.key server.key.passphrase server.pfxyinlijun@yinlijun:~/personal_github/echo-https-server/keys$ openssl pkcs12 -export -clcerts -in client.cert -inkey client.key -out client.p12Enter pass phrase for client.key:Enter Export Password:Verifying - Enter Export Password: 生成浏览器支持的p12文件1openssl pkcs12 -export -clcerts -in client.cert -inkey client.key -out client.p12 将客户端证书文件client.crt和客户端证书密钥文件client.key合并成客户端证书安装包client.pfx1openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx 以上的文件我只用到了一部分，应该有替代关系，具体我也搞不清楚:)。 不同的实现方式有用到不同的文件。我的android客户端用到了 server.bks client.p12 看了网上的一些例子，好像server.bks可以用server.crt替代。 node用到了 server.pfx 察看node的文档，server.pfx可以用server.crt和server.key替代。 服务端（nodejs）的代码123456789101112var https =require('https'), fs = require('fs');var options = &#123; key: fs.readFileSync('./keys/server.key'), cert: fs.readFileSync('./keys/server.crt'),&#125;;var app = express();var server = https.createServer(options, app);server.listen(443, function() &#123; console.log('Https server listening on port ' + 443);&#125;); android应用自有证书的验证方式将服务端证书拷贝到app资源目录下，一般是/assets/server.crt 方法一：直接根据server.crt初始化TrustManagerFactory123456789101112131415161718192021222324252627282930313233343536373839404142 CertificateFactory cf = CertificateFactory.getInstance("X.509"); InputStream caInput = new BufferedInputStream(getAssets().open("server.crt")); final Certificate ca; try &#123; ca = cf.generateCertificate(caInput); Log.i(TAG, "ca=" + ((X509Certificate) ca).getSubjectDN()); Log.i(TAG, "key=" + ((X509Certificate) ca).getPublicKey()); &#125; finally &#123; caInput.close(); &#125; String keyStoreType = KeyStore.getDefaultType(); Log.d(TAG, "keystore type:" + keyStoreType); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry("cert", ca); String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); Log.d(TAG, "tmfAlgorithm:" + tmfAlgorithm); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(tmfAlgorithm); trustManagerFactory.init(keyStore); mSSLContext = SSLContext.getInstance("TLS"); mSSLContext.init(null, trustManagerFactory.getTrustManagers(), null); URL url = new URL("https://yinlijun.com"); HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection(); urlConnection.setSSLSocketFactory(mSSLContext.getSocketFactory()); InputStream in = urlConnection.getInputStream(); copyInputStreamToOutputStream(in, System.out);&#125; catch (CertificateException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace();&#125; catch (KeyManagementException e) &#123; e.printStackTrace();&#125; catch (KeyStoreException e) &#123; e.printStackTrace();&#125; copyInputStreamToOutputStream方法如下： 1234567private void copyInputStreamToOutputStream(InputStream in, PrintStream out) throws IOException &#123; byte[] buffer = new byte[1024]; int c = 0; while ((c = in.read(buffer)) != -1) &#123; out.write(buffer, 0, c); &#125;&#125; 方法二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960try &#123; CertificateFactory cf = CertificateFactory.getInstance("X.509"); InputStream caInput = new BufferedInputStream(getAssets().open("server.crt")); final Certificate ca; try &#123; ca = cf.generateCertificate(caInput); Log.i("Longer", "ca=" + ((X509Certificate) ca).getSubjectDN()); Log.i("Longer", "key=" + ((X509Certificate) ca).getPublicKey()); &#125; finally &#123; caInput.close(); &#125; // Create an SSLContext that uses our TrustManager SSLContext context = SSLContext.getInstance("TLSv1","AndroidOpenSSL"); context.init(null, new TrustManager[]&#123; new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; for (X509Certificate cert : chain) &#123; // Make sure that it hasn't expired. cert.checkValidity(); // Verify the certificate's public key chain. try &#123; cert.verify(((X509Certificate) ca).getPublicKey()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (NoSuchProviderException e) &#123; e.printStackTrace(); &#125; catch (SignatureException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125; &#125;, null); URL url = new URL("https://yinlijun.com/"); HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection(); urlConnection.setSSLSocketFactory(context.getSocketFactory()); InputStream in = urlConnection.getInputStream(); copyInputStreamToOutputStream(in, System.out); 双向认证单向验证只能验证服务器，如果服务器也想对客户端进行验证，即所谓（双向验证），需要在连接是一起发送客户端证书。 双向认证，服务器代码1234567891011121314151617181920212223242526const tls = require('tls');const fs = require('fs');const options = &#123; pfx: fs.readFileSync('./server.pfx'), passphrase: "123456", // This is necessary only if using the client certificate authentication. requestCert: true, rejectUnauthorized: true //如果接受也非认证链接，可以删除此行。&#125;;//需要双向认证才需要配置requestCert为true。const server = tls.createServer(options, (socket) =&gt; &#123; console.log('server connected', socket.authorized ? 'authorized' : 'unauthorized'); socket.setEncoding('utf8'); socket.on('data', (data) =&gt; &#123; console.log(data); socket.write(data); &#125;); socket.on('end', (socket) =&gt; &#123; console.log("socket closed"); &#125;);&#125;);server.listen(8000, () =&gt; &#123; console.log('server bound');&#125;); 双向认证，android的代码，实现方式一server.pfx和client.p12放到/assets/目录下12345678910111213141516171819202122232425262728293031323334353637383940414243try &#123; KeyStore trustStore = KeyStore.getInstance("bks"); InputStream tsIn = getResources().getAssets().open("server.bks"); KeyStore keyStore = KeyStore.getInstance("PKCS12"); InputStream ksIn = getResources().getAssets().open("client.p12"); try &#123; keyStore.load(ksIn, "123456".toCharArray()); trustStore.load(tsIn, "123456".toCharArray()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ksIn.close(); &#125; catch (Exception ignore) &#123; &#125; try &#123; tsIn.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("X509"); keyManagerFactory.init(keyStore, "123456".toCharArray()); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); mSSLContext = SSLContext.getInstance("TLS"); mSSLContext.init(null, trustManagerFactory.getTrustManagers(), null); mSSLSocket = (SSLSocket) mSSLContext.getSocketFactory().createSocket("yinlijun.com", 8000); mSSLSocket.startHandshake(); //...&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace();&#125; catch (KeyManagementException e) &#123; e.printStackTrace();&#125; catch (KeyStoreException e) &#123; e.printStackTrace();&#125; catch (UnrecoverableKeyException e) &#123; e.printStackTrace();&#125; 双向认证，android的代码，实现方式2，用server.crt替代server.bksserver.crt和client.p12放到/assets/目录下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970try &#123; CertificateFactory cf = CertificateFactory.getInstance("X.509"); InputStream caInput = new BufferedInputStream(getAssets().open("server.crt")); final Certificate ca; try &#123; ca = cf.generateCertificate(caInput); Log.i("Longer", "ca=" + ((X509Certificate) ca).getSubjectDN()); Log.i("Longer", "key=" + ((X509Certificate) ca).getPublicKey()); &#125; finally &#123; caInput.close(); &#125; KeyStore keyStore = KeyStore.getInstance("PKCS12"); InputStream ksIn = getResources().getAssets().open("client.p12"); try &#123; keyStore.load(ksIn, "123456".toCharArray()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; ksIn.close(); &#125; catch (Exception ignore) &#123; &#125; &#125; KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("X509"); keyManagerFactory.init(keyStore, "123456".toCharArray()); // Create an SSLContext that uses our TrustManager SSLContext context = SSLContext.getInstance("TLSv1","AndroidOpenSSL"); context.init(keyManagerFactory.getKeyManagers(), new TrustManager[]&#123; new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; for (X509Certificate cert : chain) &#123; // Make sure that it hasn't expired. cert.checkValidity(); // Verify the certificate's public key chain. try &#123; cert.verify(((X509Certificate) ca).getPublicKey()); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (NoSuchProviderException e) &#123; e.printStackTrace(); &#125; catch (SignatureException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125; &#125;, null); //... 项目地址： 参考文档 How to generate self-signed certificate for usage in Express4 or Node.js HTTP SSL证书生成方法 Android安全开发之安全使用HTTPS 通过 HTTPS 和 SSL 确保安全 (要翻墙) https://nodejs.org/api/tls.html https://gist.github.com/Frank-Zhu/41e21a00df26d63cd38d]]></content>
      <tags>
        <tag>android</tag>
        <tag>nodejs</tag>
        <tag>https</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Match-react router 4.0.0 api中文文档]]></title>
    <url>%2F2016%2F11%2F25%2Freact-router-4-0-0-api-Match%2F</url>
    <content type="text"><![CDATA[原文链接 &lt;Match&gt; 匹配到地址(location)时进行UI渲染 pattern: string任何path-to-regexp可以理解的URL模式表达式1&lt;Match pattern="/users/:id" component=&#123;User&#125;/&gt; exactly: bool当为true时，只有模式表达式严格匹配时，才算匹配上。 pattern location.pathname exactly? matches? /foo /foo/bar yes no /foo /foo/bar no yes 1&lt;Match pattern="/foo" exactly component=&#123;Foo&#125;/&gt; location如果你不想匹配上下文(context)中的地址(location)时，你可以传入一个location参数来替代。1&lt;Match pattern="/foo" location=&#123;&#123; pathname: '/foo' &#125;&#125;/&gt; component当匹配到地址时渲染的React组件，渲染该组件时，会传入如下属性(props)： pattern: (string) 匹配表达式. pathname: (string) 匹配后的路径. isExact: (bool) 是否严格匹配 (v. partial). location: 匹配到的location对象. params: 根据匹配模式解析出来的参数 如下所示：12345678910111213141516171819202122class User extends React.Component &#123; render() &#123; const &#123;params, pattern, pathname, isExact, location&#125; = this.props; return (&lt;div&gt; &lt;h2&gt;User&lt;/h2&gt; &lt;div&gt; location:&#123;JSON.stringify(location)&#125; &lt;br /&gt; pattern:&#123;pattern&#125; &lt;br /&gt; pathname:&#123;pathname&#125; &lt;br /&gt; isExact:&#123;isExact ? "true" : "false"&#125; &lt;br /&gt; params:&#123;JSON.stringify(params, null, 2)&#125; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt;) &#125;&#125;&lt;Match pattern="/:user" component=&#123;User&#125;/&gt; 效果如下12345location:&#123;&quot;pathname&quot;:&quot;/kim&quot;,&quot;search&quot;:&quot;&quot;,&quot;hash&quot;:&quot;&quot;,&quot;state&quot;:null,&quot;query&quot;:null,&quot;key&quot;:&quot;a21zge&quot;&#125;pattern:/:userpathname:/kimisExact:trueparams:&#123; &quot;user&quot;: &quot;kim&quot; &#125; render: func相对于直接渲染一个组件，你可以之间传一个渲染函数，该函数被调用时，会传入组件一样的参数。 这相当于提供了一种内联(inline rendering)渲染方式，或者对Match的封装(wrapping)。12345678910111213// 非常方便的内联渲染&lt;Match pattern="/home" render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;// 对Match进行封装const MatchWithFade = (&#123; component:Component, ...rest &#125;) =&gt; ( &lt;Match &#123;...rest&#125; render=&#123;(matchProps) =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...matchProps&#125;/&gt; &lt;/FadeIn&gt; )&#125;/&gt;)&lt;MatchWithFade pattern="/cool" component=&#123;Something&#125;/&gt; children: func有时你可能需要根据匹配与否进行不同的渲染，这时，你可以使用children属性，它的类型为function，它的表现有点象render函数，但是有以下不同： (1) 不管有没有匹配上都会被调用。 (2) 回传递一个matched属性表示有没有被匹配上。 It seems unlikely you’ll need this for anything besides animating when a component transitions from matching to not matching and back, but who knows? 12345678&lt;Match children=&#123;(&#123; matched, ...rest&#125;) =&gt; ( &#123;/* 因为Animate 总是能被渲染，所以你可以利用组件的生命周期(lifecycle)来实现动画。*/&#125; &lt;Animate&gt; &#123;matched &amp;&amp; ( &lt;Something &#123;...rest&#125;/&gt; )&#125; &lt;/Animate&gt;)&#125;/&gt; &lt;/Match&gt;]]></content>
      <categories>
        <category>react router 4.0.0 api中文文档</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件生命周期]]></title>
    <url>%2F2016%2F11%2F24%2Freact-lifecycle%2F</url>
    <content type="text"><![CDATA[原文链接 实例化首次实例化 getDefaultProps getInitialState componentWillMount render componentDidMount 实例化完成后的更新getInitialStatecomponentWillMountrendercomponentDidMount 存在期组件已存在时的状态改变 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 销毁&amp;清理期 componentWillUnmount 说明生命周期共提供了10个不同的API。 getDefaultProps 作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 getInitialState 作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 componentWillMount 在完成首次渲染之前调用，此时仍可以修改组件的state。 render 必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 不能修改DOM的输出 componentDidMount 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。 在服务端中，该方法不会被调用。 componentWillReceiveProps 组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。1234567componentWillReceiveProps: function(nextProps) &#123; if (nextProps.bool) &#123; this.setState(&#123; bool: true &#125;); &#125;&#125; shouldComponentUpdate 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。 在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 componentWillUpdate 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 componentDidUpdate 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。 参考资料 React：引领未来的用户界面开发框架/寸志 范洪春 杨森 陈涌 译 – 电子工业出版社 Component Specs and Lifecycle190]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BrowserRouter-react router 4.0.0 api中文文档]]></title>
    <url>%2F2016%2F11%2F24%2Freact-router-4-0-0-api-BrowserRouter%2F</url>
    <content type="text"><![CDATA[原文链接 &lt;BrowserRouter&gt; 保持你的界面与浏览器历史记录保持同步。123&lt;BrowserRouter&gt; &lt;App/&gt;&lt;/BrowserRouter&gt; basename 所有路由的根URL，如果你的应用处于服务端的子目录, 你可以设置这个值为该子目录。 123456&lt;BrowserRouter basename=&quot;/calendar&quot; /&gt;// 假设Link标签如下所示：&lt;Link to=&quot;/today&quot;/&gt;// 那么超链接指向 &quot;/calendar/today&quot;&lt;/BrowserRouter&gt; &lt;/BrowserRouter&gt;]]></content>
      <categories>
        <category>react router 4.0.0 api中文文档</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BrowserRouter-react router 4.0.0 api中文文档]]></title>
    <url>%2F2016%2F11%2F24%2Freact-router-4-0-0-api%2F</url>
    <content type="text"><![CDATA[原文链接 &lt;BrowserRouter&gt; 保持你的界面与浏览器历史记录保持同步。123&lt;BrowserRouter&gt; &lt;App/&gt;&lt;/BrowserRouter&gt; basename 所有路由的根URL，如果你的应用处于服务端的子目录, 你可以设置这个值为该子目录。 123456&lt;BrowserRouter basename=&quot;/calendar&quot; /&gt;// 假设Link标签如下所示：&lt;Link to=&quot;/today&quot;/&gt;// 那么超链接指向 &quot;/calendar/today&quot;&lt;/BrowserRouter&gt; &lt;/BrowserRouter&gt;]]></content>
      <tags>
        <tag>react</tag>
        <tag>react-router</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu编译android 6.0源代码环境搭建]]></title>
    <url>%2F2016%2F11%2F16%2Fubuntu%E7%BC%96%E8%AF%91android%E6%BA%90%E4%BB%A3%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装jdk1sudo apt-get install openjdk-7-jdk openjdk-7-jre 如果之前系统是其他版本的JDK，需要把环境变量切换过来。 jdk版本错误会导致编译错误，如1234567891011prebuilts/sdk/api/23.txt:41822: error 9: Removed public constructor android.widget.Toolbar.LayoutParams.Toolbar.LayoutParams(LayoutParams)prebuilts/sdk/api/23.txt:41823: error 9: Removed public constructor android.widget.Toolbar.LayoutParams.Toolbar.LayoutParams(MarginLayoutParams)prebuilts/sdk/api/23.txt:41824: error 9: Removed public constructor android.widget.Toolbar.LayoutParams.Toolbar.LayoutParams(LayoutParams)prebuilts/sdk/api/23.txt:42895: error 9: Removed public constructor java.io.ObjectInputStream.GetField.ObjectInputStream.GetField()prebuilts/sdk/api/23.txt:42955: error 9: Removed public constructor java.io.ObjectOutputStream.PutField.ObjectOutputStream.PutField()prebuilts/sdk/api/23.txt:43623: error 9: Removed public constructor java.lang.Character.Subset.Character.Subset(String)prebuilts/sdk/api/23.txt:46730: error 9: Removed public constructor java.nio.channels.Pipe.SinkChannel.Pipe.SinkChannel(SelectorProvider)prebuilts/sdk/api/23.txt:46735: error 9: Removed public constructor java.nio.channels.Pipe.SourceChannel.Pipe.SourceChannel(SelectorProvider)prebuilts/sdk/api/23.txt:47370: error 9: Removed public constructor java.security.KeyStore.Builder.KeyStore.Builder()prebuilts/sdk/api/23.txt:47379: error 9: Removed public constructor java.security.KeyStore.CallbackHandlerProtection.KeyStore.CallbackHandlerProtection(CallbackHandler)prebuilts/sdk/api/23.txt:47391: error 9: Removed public constructor java.security.KeyStore.PasswordProtection.KeyStore.PasswordProtection(char) 安装其他工具包1sudo apt-get install git gitg gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 libarchive-zip-perl]]></content>
      <tags>
        <tag>android</tag>
        <tag>ubuntu</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何下载安装openJDK]]></title>
    <url>%2F2016%2F11%2F15%2Fhow-to-download-openjdk%2F</url>
    <content type="text"><![CDATA[JDK 8Debian, Ubuntu1$ sudo apt-get install openjdk-8-jre openjdk-8-jre只包含运行时环境(Java Runtime Environment）。如果你想开发java程序，请安装openjdk-8-jdk。 Fedora, Oracle Linux, Red Hat Enterprise Linux1$ su -c &quot;yum install java-1.8.0-openjdk&quot; java-1.8.0-openjdk只包含运行时环境(Java Runtime Environment）。如果你想开发java程序，请安装java-1.8.0-openjdk-devel。 JDK 7Debian, Ubuntu1$ sudo apt-get install openjdk-7-jre openjdk-7-jre只包含运行时环境(Java Runtime Environment）。如果你想开发java程序，请安装openjdk-7-jdk。 Fedora, Oracle Linux, Red Hat Enterprise Linux1$ su -c &quot;yum install java-1.7.0-openjdk&quot; java-1.7.0-openjdk只包含运行时环境(Java Runtime Environment）。如果你想开发java程序，请安装java-1.7.0-openjdk-devel。 JDK 6Debian, Ubuntu1$ sudo apt-get install openjdk-6-jre openjdk-6-jre只包含运行时环境(Java Runtime Environment）。如果你想开发java程序，请安装openjdk-6-jdk。 Fedora, Oracle Linux, Red Hat Enterprise Linux1$ su -c &quot;yum install java-1.6.0-openjdk&quot; java-1.6.0-openjdk只包含运行时环境(Java Runtime Environment）。如果你想开发java程序，请安装java-1.6.0-openjdk-devel。 参考http://openjdk.java.net/install/]]></content>
      <tags>
        <tag>openjdk</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu利用update-alternatives配置java]]></title>
    <url>%2F2016%2F11%2F15%2Fubuntu%E5%88%A9%E7%94%A8update-alternatives%E9%85%8D%E7%BD%AEjava%2F</url>
    <content type="text"><![CDATA[利用Android Studio开发，经常会碰到JDK版本的切换问题，安装好新版本的jdk之后，需要先配置到可选项。123yinlijun@sj:~$ sudo update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_101/bin/java 100update-alternatives: 警告: /etc/alternatives/java has been changed (manually or by a script); switching to manual updates onlyyinlijun@sj:~$ sudo update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_101/bin/javac 100 然后，选择默认的JDK版本：1234567891011121314151617181920212223yinlijun@sj:~$ sudo update-alternatives --config java有 3 个候选项可用于替换 java (提供 /usr/bin/java)。 选择 路径 优先级 状态------------------------------------------------------------ 0 /opt/jdk1.6.0_37/bin/java 10000 自动模式 1 /opt/jdk1.6.0_37/bin/java 10000 手动模式 2 /opt/jdk1.8.0_101/bin/java 100 手动模式 3 /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java 1051 手动模式要维持当前值[*]请按回车键，或者键入选择的编号：2update-alternatives: using /opt/jdk1.8.0_101/bin/java to provide /usr/bin/java (java) in 手动模式yinlijun@sj:~$ sudo update-alternatives --config javac有 3 个候选项可用于替换 javac (提供 /usr/bin/javac)。 选择 路径 优先级 状态------------------------------------------------------------ 0 /opt/jdk1.6.0_37/bin/javac 10000 自动模式 1 /opt/jdk1.6.0_37/bin/javac 10000 手动模式 2 /opt/jdk1.8.0_101/bin/javac 100 手动模式* 3 /usr/lib/jvm/java-7-openjdk-amd64/bin/javac 1051 手动模式要维持当前值[*]请按回车键，或者键入选择的编号：2]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>update-alternatives</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 12.04 生成桌面图标]]></title>
    <url>%2F2016%2F11%2F15%2Fmake-ubutun-desktop%2F</url>
    <content type="text"><![CDATA[在Ubuntu上从网上下载压缩包版本（非.deb包）的应用程序之后，是不生成桌面图表的，比如网上下载的Android Studio, 所以需要自己做一个桌面图标。 进入到/usr/share/applications/目录下 1cd /usr/share/applications/ 新建一个android-studio.desktop文件。 1vim android-studio.desktop 输入一下内容123456789Version=2.2Name=Android StudioGenericName=Android IDEComment=Android DevelopmentExec=/home/yinlijun/android_toolchain/android-studio/bin/studio.sh %UTerminal=falseIcon=/home/yinlijun/android_toolchain/android-studio/bin/studio.pngType=ApplicationCategories=Android;IDE; 保存退出之后，在应用程序里面就可以找到，绑定了图标的应用程序，可以将其固定到启动器上。]]></content>
      <tags>
        <tag>android studio</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置user.name和user.email]]></title>
    <url>%2F2016%2F11%2F15%2Fgit%E9%85%8D%E7%BD%AEuser-name%E5%92%8Cuser-email%2F</url>
    <content type="text"><![CDATA[github在统计提交的时候，会判断邮箱是否跟github的登陆邮箱匹配，不匹配则不计算活跃度，即不生成小绿块。 获取配置1234yinlijun@yinlijun:~/personal_github/johnny-blog$ git config user.emailaaa@aaa.comyinlijun@yinlijun:~/personal_github/johnny-blog$ git config user.nameaaa 设置当前仓库的user.name/user.email12yinlijun@yinlijun:~/personal_github/johnny-blog$ git config user.email aaayinlijun@yinlijun:~/personal_github/johnny-blog$ git config user.email aaa@aaa.com 设置全局user.name/user.email12yinlijun@yinlijun:~/personal_github/johnny-blog$ git config --global user.name yinlijunyinlijun@yinlijun:~/personal_github/johnny-blog$ git config --global user.email yinlijun2004@gmail.com 如果当前仓库未设置user.name/user.email则采用全局的user.name/user.email，否则当前仓库的user.name/user.email会覆盖全局的user.name/user.email。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows配置mongdb记录]]></title>
    <url>%2F2016%2F11%2F09%2Fwindows%E9%85%8D%E7%BD%AEmongdb%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[刚给windows电脑配置了mongdb记录一下。 前往官网下载合适的安装包，我选择的是msi安装包，也可以选择下载zip包。 运行msi安装包（默认安装在C盘，没找到在哪里可以修改盘符）。 在D:\下创建好相关文件夹 打开命令提示符，进入到mongodb安装文件夹下的bin目录 输入如下命令，注册MongoDB服务 1mongod.exe --logpath D:\MongoDB\data\log\MongoDB.log --logappend --dbpath D:\MongoDB\data\db --directoryperdb --storageEngin=mmappv1 --serviceName MongoDB --install 启动MongoDB服务 1net start MongoDB]]></content>
      <tags>
        <tag>windows</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下文件路径太深，无法删除解决办法]]></title>
    <url>%2F2016%2F11%2F08%2Fwindows%E4%B8%8B%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%A4%AA%E6%B7%B1%EF%BC%8C%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[windows下npm开发时，有时候node_modules/下的目录嵌套太深，导致无法删除项目。 npm社区贡献了一个工具windows-node-deps-deleter可供删除这样的目录。 12345678910E:\vscode&gt;npm install -g windows-node-deps-deleterC:\Users\xx\AppData\Roaming\npm\wnddel -&gt; C:\Users\xx\AppData\Roaming\npm\node_modules\windows-node-deps-deleter\wnddel.jswindows-node-deps-deleter@0.1.1 C:\Users\xx\AppData\Roaming\npm\node_modules\windows-node-deps-deleter└── fs-extra@0.13.0 (ncp@1.0.1, jsonfile@2.4.0, rimraf@2.5.4)E:\vscode&gt;wnddel react-todo-listDeleting &quot;react-todo-list&quot; ...&quot;react-todo-list&quot; deleted. 参考：windows-node-deps-delete]]></content>
      <tags>
        <tag>windows</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore无效，不能过滤某些文件]]></title>
    <url>%2F2016%2F11%2F06%2Fgitignore%E6%97%A0%E6%95%88%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%BF%87%E6%BB%A4%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[利用.gitignore过滤文件，如编译过程中的中间文件，等等，这些文件不需要被追踪管理。 现象： 在.gitignore添加file1文件，以过滤该文件，但是通过Git status查看仍显示file1文件的状态。 原因： 在git库中已存在了这个文件，之前push提交过该文件。 .gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了 解决： 需要在git库中删除该文件，并更新。 然后再次git status查看状态，file1文件不再显示状态。]]></content>
      <tags>
        <tag>git</tag>
        <tag>.gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能Javscript - 笔记]]></title>
    <url>%2F2016%2F11%2F05%2FHigh-Performance-Javascript%2F</url>
    <content type="text"><![CDATA[第一章 加载和执行减少Javascript加载对性能的影响 &lt;/body&gt;闭合标签之前，将所有&lt;javascript&gt;标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染 合并脚本，减少&lt;javascript&gt;标签 使用&lt;javascript&gt;标签的defer属性1&lt;script type='text/javascript' src='file1.js' defer&gt;&lt;/script&gt; 利用动态创建的&lt;javascript&gt;元素来下载并执行代码 1234567var script = document.createElemnet('script');script.type = 'text/javascript';script.onload = function() &#123; alert('Script loaded!');&#125;script.src = 'file1.js';document.getElementByTagName('head')[0].appendChild(script); 使用XHR对象下载Javascript代码并注入页面中 123456789101112var xhr = new XMLHttpRequest();xhr.open('get', 'file1.js', true);xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; var script = document.createElemnet('script'); script.type = 'text/javascript'; script.text = xhr.responseText; document.body.appendChild(script); &#125; &#125;&#125; 几种类库加载js的方式 YUI3 123456&lt;script type='text/javascript' src='http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js'&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt; YUI().use('dom', function(Y) &#123; Y.DOM.addClass(document.body, 'loaded'); &#125;)&lt;/script&gt; LazyLoad 123456&lt;script type='text/javascript' src='lazyload-min.js'&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt; LazyLoad.js('the-rest.js', function() &#123; Applicationn.init(); &#125;)&lt;/script&gt; LABjs 12345678&lt;script type='text/javascript' src='lab.js'&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt; $LAB.script('first-file.js') .wait() .script('the-rest.js') .wait(function() &#123; Applicationn.init(); &#125;) 第二章 数据存取在Javascript中，数据存储的位置会对代码整体性能产成重大影响。数据存储共有4中方式：字面量、变量、数组项、对象成员。它们有着各自的性能特点。 访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。 由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域中的位置越深，访问所需时间就越长。由于全局变量总处在作用域的最末端，因此访问速度时最慢的。 避免使用with语句。 嵌套的对象成员会明显影响性能，尽量少用。 属性或方法在原型链中的位置越深，访问它的速度也越慢。 通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善Javascript性能，因为局部变量访问速度更快。 第三章 DOM编程访问和操作DOM时现在Web应用的重要部分。但每次穿越链接ECMAScript和DOM都会有性能消耗，为了减少DOM编程带来的消耗，请记住以下几点： 最小化DOM访问次数，尽可能在Javascript端处理。 如果需要多次访问某个DOM节点，请使用局部变量存储它的引用。 小心处理HTML集合，把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它靠背到一个数组中。 如果可能的话，使用速度更快的API，比如querySelecetAll()和firstElementChild。 要留意重排和重绘，批量修改样式时，离线操作DOM树，使用缓存，并减少布局信息的次数。 动画中使用绝对定位，使用拖放代理。 使用事件委托来减少事件处理器的数量。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android studio编译错误: *** 目标模式不含有“%”。 停止。]]></title>
    <url>%2F2016%2F11%2F05%2Fandroid-studio%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF-%E7%9B%AE%E6%A0%87%E6%A8%A1%E5%BC%8F%E4%B8%8D%E5%90%AB%E6%9C%89%E2%80%9C-%E2%80%9D%E3%80%82-%E5%81%9C%E6%AD%A2%E3%80%82%2F</url>
    <content type="text"><![CDATA[Android Studio NDK编译出现如下错误： target pattern contains no `%’. Stop中文： 目标模式不含有“%”。 停止。可能是obj目录的问题，需要删掉。在工程目录下find所有的obj目录1find . -name obj]]></content>
      <tags>
        <tag>android studio</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS权威值南-笔记]]></title>
    <url>%2F2016%2F09%2F06%2FCSS-The-Definitive-Guide%2F</url>
    <content type="text"><![CDATA[第一章 css和文档 文档内定义样式 &lt;style type=&quot;text/css&quot;&gt; @import url(sheet2.css) h1 {color: maroon;} &lt;/style&gt; 引入css文件 &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;sheet1.css&quot; media=&quot;all&quot; /&gt; 第二章 选择器 ID选择器和指定id的属性选择器不是一回事，h1#page-title和h1[id=”page-title”]之间有差别。 p.warning和p[class~=”warning”]是等价的，但是p[class=”warning”]匹配只有一个class的p元素。 类似的还有[foo^=”bar”] 选择foo属性值以bar开头的所有元素 [foo$=”bar”] 选择foo属性值以bar结尾的所有元素 [foo*=”bar”] 选择foo属性值中含有bar子串的所有元素 后代选择器中，两个元素之间的层次间隔可以是无限的，如果想匹配直接相连的父子元素，可以使用子结合符”&gt;” 兄弟元素选择器 h1 + p {margin-top: 0} 伪类选择器，伪类的顺序很重要 link-visited-focus-hover-active 连接伪类 :link 未访问的超连接 :visited 已访问的超连接 动态伪类 :focus 拥有焦点的元素（可以接受键盘输入或者能已某种方式激活的元素） :hover 鼠标指针悬停的元素 :active 用户输入激活的元素 静态伪类 :first-child 第一个子元素 :first-letter 第一个字母 :first-line 第一行 :lang(fr) 根据语言选择 :first-letter和:first-line只能用于标记或段落之类的块元素，不能用于超连接等行内元素。 第三章 结构和层叠 选择器的特殊性 给定的各个ID属性值，加0，1，0，0 给形的各个类的属性值，属性选择或者伪类，加0，0，1，0 给定的各个元素和伪元素加0，0，0，1 结合符和通配选择器对特属性没有任何贡献 样式继承 文本颜色可被继承 border不能被继承，一般的大多数框模型属性不能被继承（包括外边框，内边距，背景和边框） 继承的值没有特殊性，连0特殊性都没有p(61)，因此需要避免不加区别的使用通配选择器。 层叠权重大小顺序 读者的重要声明 创作人员的重要声明 创作人员的正常声明 读者的正常声明 用户代理声明 第四章 值和单位 颜色表示 命名颜色 {color: gray;} 函数式RGB {color: rgb(100%, 50%, 50%);}，或者{color: rgb(52, 95, 153);} 十六进制RGB {color: #ff0000;} 如果3组各自成对，可以简写#f00，相当于#ff0000 WEB安全颜色 RGB百分表示法，能被20整除的颜色，如rgb(60, 40, 120) 十六进制，使用00，33，66，99，cc，ff，如#99ffcc 长度单位 绝对长度单位 在打印文档的样式表时更为有用，Web设计中不使用绝对长度单位。 英寸 (in) 厘米(cm) 1in = 2.54cm 毫米(mm) 1in = 25.4mm 点(pt) 1in = 72pt 派卡(pc) 1pc = 12pt, 6pc = 1in 相对长度单位 em (em-height) 1em定义未一种给定字体的font-size的值，随元素的不同而不同，国外最常用，也是未来的趋势，更容易适配移动端。 ex (x-height) 1ex定位未一种给定字体的小写x的高度，不同字体ex的值不同。 px像素 第五章 字体css定义了5中通用字体 Serif 成比例的有上下短线的字体 Sans-serif 成比例的，没有上下短线 Monospace 不成比例，通常用于模拟打字机打出的问题 Cursive 手写体 Fantasy 无法用任何特征来定义的字体 特定字体：如Times，Verdana, Helvetica, Arial等，每一种特定的字体都会落入上述通用系列中。 font-family 如h1 {font-family: Georgia, serif}, Georgia是特定字体，serif是通用字体。 font-weight normal bold bolder lighter 100/200/300/400/500/600/700/800/900 font-size xx-small/x-small/small/medium/large/x-large/xx-large/smaller/larger &lt;length&gt;/&lt;percentage&gt; font-style字体风格 italic/oblique/normal/inherit font-variant 字体变形 small-caps 首字母大写 normal inherit 第六章 文本属性 text-indent 首行缩进 &lt;length&gt; 如：p {text-indent: 3em} &lt;percentag&gt; 相对于父元素宽度 inhert text-align 水平对齐 left right center justify 两端对齐，在打印领域很常见 inherit line-height 行高，定义了基线之间的距离，而不是字体大小，可以控制行间距。行间距=行高-字体大小 &lt;length&gt; &lt;percentage&gt; &lt;number&gt; normal inherit vertical-align 行内元素和表单元格的垂直方向对齐 base-line 基线对齐，元素的底端和副元素的基线对齐 sub/super 上标/下标，相对于基线升高/降低 bottom 元素行内框的底端和行框的底端对齐 text-bottom 元素行内框的底端和文本的底端对齐 top 与bottom相反 text-top 与text-bottom相反 middle 居中对齐 &lt;percentage&gt; &lt;length&gt; inherit word-spacing 字间隔 &lt;length&gt; normal inherit letter-spacing 字母间隔 &lt;length&gt; normal inherit text-transform uppercase 全大写 lowercase 全小写 capitalize 单词首字母大写 none inherit text-decoration 文字效果 none underline 下划线 overline 上划线 line-through 中划线 blink inherit text-shadow none 颜色值和三个长度值 text-shadow: silver 2px 2px 2px; white-space normal 合并空白符，忽略换行符，允许自动换行。 nowrap 合并空白符，忽略换行符号，不允许自动换行。 pre 保留空白符号，保留换行符号，不允许自动换行。 pre-wrap 保留空白符，保留换行符，允许自动换行。 pre-line 合并空白符，保留换行符，允许自动换行。 inherit direction 文本方向 ltr rtl inherit 第七章 基本视觉格式化水平格式化七大水平属性 margin-left border-left padding-left width padding-right border-right maring-right 这7个属性值加起来就是元素包含块的宽度，这往往是副元素的width值。width就是左内边距到右内边距的距离。这7个属性中，只有3个属性可以设置为auto: margin-left, width, margin-right，可以用auto弥补实际值和所需总和的差距。如果三个值都为非auto的某个值，这些格式化属性过分受限，此时会强制设置margin-right为auto.不止一个auto的情况： margin-left和margin-right为auto，此时元素居中，与text-align:center的区别，text-align只应用块级元素的内联内容，并不能使元素居中。 margin-left和width为auto，此时margin-left为0，width会填满剩余包块。 margin-right和width为auto，此时margin-right为0，width填满剩余包块。 margin-left和margin-right和width都为auto，此时margin-left和margin-right都为0,width会填满包块。这种情况和默认是相同的。 水平外边距不会合并，父元素的内边距，边距和外边距可能影响子元素。 负外边距 负外边距时， 会使得内容宽度超出包块，因为根据等式父包块width=7大水平之和，margin-left或margin-right为负时，width要增大。 垂直格式化如果元素的内容的高度，大于元素框的高度，用户代理的具体行为将取决于overflow属性。垂直格式化的七大属性 margin-top border-top padding-top height padding-bottom border-bottom margin-bottom 这7个属性值的值和必须等于含块的height，其中，3个值可以设置为auto，margin-top，height，margin-bottom，如果margin-top或margin-bottom设置为auto则自动计算0，这就是为什么不容易设置元素为垂直居中，这与水平时不一样的。对于定位元素，上下边距为auto时，处理不同。 如果没有显式声明包含块的height，百分数高度为重置为auto，如果块级中场元素的height设置为auto，显示时的高度将恰好足以包含其内联内容。如果块级正常流元素高度设置为auto，而且只有块级子元素，其默认高度将是从最高块级子元素的外边框边界到最低块级子元素外边框边界之间的距离。不过，如果块级元素有padding或者border，则高度则是最高子元素的上外边距到其最低子元素的下外边距边界之间的距离。 合并垂直外边距垂直合并只引用与外边距，不会应用于内边距和边框。负的下外边距会使段落看上去向下拉，负的上边会使段落看上去向上拉。 第八章 内边距、边框和外边距 border-style none hidden dotted dashed solid double groove ridge inset outset 设置多个边框样式 p.asize {boder-style: solid dashed dotted solid;} boder-top-style/boder-right-style/border-bottom-style/border-left-style 单独设置边框样式 border-width边框宽度 thin medium thick &lt;length&gt; border-top-width/border-right-width/border-bottom-width/border-left-width单独设置宽度 boder-color边框颜色 &lt;color&gt; transparent 透明 border-top-color/border-right-color/border-bottom-color/border-left-color单独设置颜色 border-top/boder-right/border-bottom/border-left单独设置边框 [&lt;border-width&gt;] [&lt;border-style&gt;][boder-color] border 全局边框，应用到四条边 [&lt;border-width&gt;] [&lt;border-style&gt;][boder-color] 对于只包含文本的行，能改变行间距离的属性只有line-height, font-size和vertical-align。行内元素使用正左右外边距，可以多出来水平空间，负的左右外边距会使行内元素与其他内容重叠。行内元素的边框，不会改变行高。行内元素使用正的左右边框可以多出来水平空间。 padding 内边距 &lt;length&gt; &lt;percentage&gt; 行内非替换元素使用左右内边距时，可以多出来水平空间，而上下边距不会改变行高。可以想图像使用内边距,外边距，边框时，它可以改变行高，也可以水平方向留出距离。 background-color 背景元素 &lt;color&gt; transparent background-image 如body {background-image: url(bg23.gif)} &lt;uri&gt; none background-repeat 有方向的重复 repeat repeat-x repeat-y no-repeat background-position 背景定位 &lt;percentage&gt; &lt;length&gt; left/center/right/top/bottom background-position单个关键字等价center: cener centertop: top center或者center topbottom: bottom center或者center bottomleft: left center 或者center leftright: right center 或者center right background-attachment scroll 跟随文档滚动 fixed 不跟随文档滚动 background 简写属性 &lt;background-color&gt; || &lt;background-image&gt; || &lt;backgroud-repeat&gt; || &lt;background-attachment&gt; || &lt;background-position&gt; 第十章 浮动和定位 float left right none 浮动元素会从文档的正常流中删除，它还是会影响布局。其他内容会环绕元素，浮动元素的外边距不会合并 position static 默认 块元素生成一个矩形框，行内元素创建一个或多个行框，置于父元素中 relative 元素偏移某个距离，元素仍保持未定位前的形状，它原本占据的空间仍保留 absolute 元素框从文档流中完全删除，并相对于其包含块定位。 fixed 元素的表现类似于absolute，不过，其包含块是视窗本身。 偏移属性，在position为relative,absolute和fixed时，可以设置偏移属性top right bottom left &lt;length&gt; &lt;percentage&gt; auto 初始值 包含块 根元素的包含块，由用户代理建立，即html元素或body元素对于一个非根元素，如果其position时relative或static，包含块则由最近的块级框，表单元格或行内块祖先框的内容边界构成。对于一个非根元素，如果其position时absolute，包含块则由最近的position值不是static的祖先元素。 overflow visible hidden scroll auto]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQeury 第四章-笔记]]></title>
    <url>%2F2016%2F09%2F05%2Fchapter-4%2F</url>
    <content type="text"><![CDATA[第四章 jQuery中的事件和动画 window.onload方法，相当于jQuery中的$(window).load(function(){})方法。都是等文档中的所有元素加载完成时调用，包括关联css文件和javascript文件。 $(document).ready(function() {})则不会等待关联文件下载完，在DOM准备好之后就会调用。 $(window).load(function(){})可以调用多次，都会执行，而window.onload只会调用最后一次赋予的函数。 $(document).ready(function() {})可以简写为$(function() {}); 事件绑定 bind(type [, data], fn);第1个参数是事件类型，包括focus、load、click、dbclik等。，第2个参数可选，作为event.data传递，第3个参数是回调函数。示例： 12345$(function()&#123; $('#panel h5.head').bind('click', function(e) &#123; $(this).next().show(); &#125;)&#125;) bind函数可以级联，如 12345$('#panel h5.head').bind('mouseover', function(e) &#123; $(this).next().show();&#125;).bind('mouseout', function(e) &#123; $(this).next().hide();&#125;) bind可以简写，如 123$('#panel h5.head').click(function(e) &#123; $(this).next().toggle();&#125;) 合成事件 jQuery有两个合成事件，hover()和toggle(),都有两个回调函数作为参数，可以看成是语法糖。hover表示移入移出两个事件，toggle表示前后两次点击事件，如 12345$('#panel h5.head').hover(function() &#123; $(this).next().show(); //划过时显示下一个元素&#125;, function() &#123; $(this).next().hide(); //划出隐藏下一个元素&#125;) 12345$('#panel h5.head').toggle(function() &#123; $(this).next().show(); //点击时显示下一个元素&#125;, function() &#123; $(this).next().hide(); //再次点击时隐藏下一个元素&#125;) 事件对象的属性 event.type 事件类型，字符串格式，如’click’, ‘dbclick’, ‘load’等。 event.preventDefault()阻止默认行为，可以用return false代替。 event.stopProgagation()组织事件冒泡，可以用return false代替。 event.target 触发事件的元素。 event.pageX event.pageY,相对于页面的x，y坐标。 event.which 不同事件含义不同，鼠标事件表示那个键，键盘事件表示键值。 event.metaKey ctl键是否按下。 移除事件 unbind([type],[data]) 如果没有参数，表示删除所有事件。 如果只提供type，表示移除所有type对应的事件回调。 如果传递了2个参数，表示对应的处理函数会被删除。 单次事件 one(type, [data], fn);执行一次后，事件回被移除。 事件模拟 原生事件 $(‘#btn’).trigger(‘click’)或者$(‘#btn’).click(); 自定义事件1234567891011121314151617$('#btn').bind('myClick', function()&#123; $('#test').append('&amp;lt;p&gt;我的自定义事件&amp;lt;/p&gt;')&#125;);$('#btn').trigger('myClick'); //触发事件。``` - 传递数据```javascript$('#btn').bind('myClick', function(event, msg1, msg2)&#123; $('#test').append('&amp;lt;p&gt;我的自定义事件&amp;lt;/p&gt;')&#125;);$('#btn').trigger('myClick'. ['参数1'，'参数2']); //触发事件。``` - 执行默认操作 triggerHandler，例如，只触发focus事件，但是不获取焦点（浏览器默认行为）```javascript$('input').triggerHandler('focus'); 事件命名空间 添加命名空间123456$('#div').bind('mouseover.plugin', function() &#123;&#125;)$('#btn').click(function() &#123; $('#div').unbind('.plugin'); //移除上面的事件。&#125;) 动画 show(duration) 显示元素，duration不为0时，表示显示动画。将元素display属性从’none‘设置为原来的值 hide(duration) 隐藏元素，duration不为0时，表示隐藏动画。将元素display属性设置为’none’ fadeIn(duration) 与show一样，但是不改变display样式。 fadeOut(duration) 与hide一样，但是不改变display样式。 slideUp(duration)和slideDown(duration)，只改变高度。 animate(param, speed, callback) param 包含样式属性值，如{left: ‘400px’, top: ‘400px’}，可累加或累减，如{left: ‘+=400px’} speed 动画时间 callback 动画完成回调-累加动画 12345$('#panel').animate(&#123;left:'400px', height:'200px', opacity:1&#125;, 3000) .animate(&#123;top:'200px', width:'200px'&#125;, 3000， function() &#123; consle.log('animate done'); &#125;) .fadeOut('slow'); 停止动画stop([clearQueue], [gotoEnd]) 判断是否处于动画状态 $(element).is(‘:animated’) 延迟动画delay(duration),延迟一段时间开始动画，$(this).animate({left:’400px’}).delay(200); 其他动画方法 toggle(speed, [callback]) 显示/隐藏元素 slideToggle(speed, [easing], [callback])通过改变高度来显示/隐藏元素 fadeTo(speed, opacity, [callback]) 通过改变不透明度来显示/隐藏元素 fadeToggle(speed, [easing], [callback]) 通过不透明度来显示/隐藏元素。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQeury 第三章-笔记]]></title>
    <url>%2F2016%2F09%2F03%2Fchapter-3%2F</url>
    <content type="text"><![CDATA[第三章 jQuery中的DOM操作 查找DOM节点 1var $li = $('ul li:eq(1)'); //获取&lt;ul&gt;里的第二个&lt;li&gt;节点 查找属性节点 12var $para = $('p'); var p_txt = $para.attr('title'); 创建元素节点 1var $li = $('&lt;li&gt;&lt;/li&gt;'); 创建文本节点 1var $li = $('&lt;li&gt;香蕉&lt;/li&gt;'); 创建属性节点 1var $li = $('&lt;li title="香蕉"&gt;香蕉&lt;/li&gt;'); 插入节点的方法 append 追加元素。$(‘p’).append($(“&lt;b&gt;你好&lt;/b&gt;”))，A.append(B)之后，A和B是父子关系。 appendTo 跟append相反，A.append(B) 相当于 B.appendTo(A) prepend 插入到前面 prependTo 跟prepend相反 after 在每个匹配元素之后插入内容，A.after(B)之后，A与B是兄弟元素 intertAfter跟after相反，A.after(B)相当于B.instertAfter(A) before，跟after相反 insertBefore，A.before(B)相当于B.insertBefore(A) 删除节点的方法 remove 删除匹配的元素 $(‘ul li:eq(1)’).remove()，删除第二个li元素，remove返回值是删除的元素 detach 与remove不同，detach会保留所有该元素绑定的事件，附加的数据等。 empty 清空节点 复制节点 clone，可以传入一个boolean参数表示是否同时复制元素中所绑定的事件。 替换节点 replaceWith， A.replaceWith(B)，用B替换A replaceAll 跟replaceWith相反，A.replaceWith(B)相当于B.replaceAll(A) 包裹节点 wrap $(‘strong’).wrap(‘&lt;b&gt;&lt;/b&gt;’) 用&lt;b&gt;标签将&lt;strong&gt;标签包起来，如果有多个匹配，则每个元素单独包裹。 wrapAll，将所有的元素用一个元素来包裹。如果匹配的节点之间有其他节点，其他节点会被放到包裹元素之后。 wrapInner 将子内容（包括文本节点）包裹起来。 获取属性，$(‘p’).atter(‘title’) 设置属性 $(‘p’).attr(‘title’, ‘your title’) 设置单个属性 $(‘p’).attr({‘title’, ‘your title’, ‘name’: ‘test’})，设置多个属性 删除属性 $(‘p’).removeAttr(‘title’); 获取样式 $(‘p’).attr(‘class’)获取&lt;p&gt;元素的class 设置样式 $(‘p’).attr(‘class’, ‘high’) 设置样式 追加样式 $(‘p’).addClass(‘another’) 移除样式 $(‘p’).removeClass(‘another’) 移除一个样式 $(‘p’).removeClass(‘another high’) 移除多个样式 切换样式 $(‘p’).toggleClass(‘another’)，如果another类名不存在则添加之，否则删除之 判断是否含有某个样式 $(‘p’).hasClass(‘another’) html()方法 获取或设置html内容，相当于javascript的innerHTML属性 text() 获取或设置文本内容，相当于javascript的innerText属性 获取: var text = $(‘p’).text() 设置 $(‘p’).text(‘你喜欢的水果是’) val()方法 获取或设置value，相当于javascript的value属性 遍历节点 children() 返回子节点（DOM原声节点，非jQuery节点） next()方法，获取紧临的同辈元素，也就是返回下一个兄弟节点。 prev()，跟next相反，返回上一个兄弟节点 siblings()返回前后所有的同辈元素。 closest() 取得最近的匹配元素，往父控件追溯。如$(e.target).closest(‘li’).css(‘color’, ‘red’);给点击的目标元素附近的li元素添加颜色。 parents() 获得集合中每个匹配元素的祖先元素。 parent() 获得集合中每个匹配元素的父级元素。 find() / filter() / nextAll() / prevAll() 等。 获取样式 $(‘p’).css(‘color’) 获取&lt;p&gt;的样式颜色 设置样式 $(‘p’).css(‘color’, ‘red’); $(‘p’).css({“fontSize”: “30px”, “backgroundColor”: “#888888”‘}); 元素定位 offset()，获取元素在当前视窗中的相对偏移。 position() 获取元素相对于最近的一个position样式为relative或absolute（为啥）的父节点的相对偏移。 scrollLeft() 获取或设置水平滚动条的位置 scrollRight() 获取或设置垂直滚动条的位置。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锋利的jQeury 第二章-笔记]]></title>
    <url>%2F2016%2F09%2F02%2Fchapter-2%2F</url>
    <content type="text"><![CDATA[第二章 jQuery选择器基本选择器 #id 匹配id, $(&#39;#test&#39;) .class 匹配类, $(&#39;.test&#39;) element 匹配标签, $(&#39;div&#39;) * 匹配所有元素, $(&#39;*&#39;) selector1, select2,...,selectN 匹配集合，如$(‘div, span, p.myClass’) 层次选择器 $(&#39;ancestor decendant&#39;) 选择后代元素 $(&#39;parent &gt; child&#39;) 选择子元素 $(&#39;prev + next&#39;) 选择紧接在prev后的next元素，如: $(&#39;.one + div&#39;)，选择one之后的下个一个div同辈元素 $(&#39;prev ~ siblings&#39;) 选择prev后的所有siblings元素，如$(&#39;#two ~ div&#39;)选择two之后的所有div同辈元素 过滤选择器 :first 选取第一个元素，它只返回一个元素。 如$(&#39;div:first&#39;)选取第一个div元素。 :last 选取最后一个元素，它只返回一个元素。 :not(selector) 取出所有给定选择器匹配的元素，如$(&#39;input:not(.myClass)&#39;),选取class不是myClass的input元素 :even 选取索引为偶数的元素，索引从0开始 :odd 选取奇数索引元素 :eq(index) 选取指定索引元素 :gt(index) 选取大于索引的元素 :lt(index) 选取小于索引的元素 :header 选取所有标题元素 如$(&#39;:header&#39;)，选取网页中所有&amp;lt;h1&gt;,&amp;lt;h2&gt;,&amp;lt;h3&gt;;.... :animated 选取所有正在执行动画的元素 如：$(&#39;div:animated&#39;)选取正在执行动画的所有div元素 :focus 选取当前获取焦点的元素 如$(&#39;:focus&#39;)，获取当前获取焦点的元素 内容过滤选择器 :contains(text) 选取文本内容含有text的元素, 如$(&#39;div:contains(&quot;我&quot;)&#39;),选取文本含有我的div元素 :empty 选取不包含子元素或者文本为空的元素, 如$(&#39;div:empty&#39;)选取不包含子元素的div元素 :has(selector) 选取含有选择器的所匹配的元素的元素，如$(&#39;div:has(p)&#39;)，选取含有p元素的div元素 :parent 选取含有子元素或文本的元素 如$(&#39;div:parent&#39;),选取拥有子元素的div元素 可见性过滤器 :hidden 选取所有不可见元素, 如$(&#39;:hidden&#39;), 选取所有不可见元素，$(&#39;input:hidden&#39;)选取所有不可见的input元素 :visible 选取所有可见元素 属性过滤选择器 [attr] 选取拥有此属性的元素, 如$(&#39;div[id]&#39;), 选取拥有属性id的元素 [attr=val] 选取attr属性为val的元素如, $(&#39;div[title=test]&#39;)选取title为test的div元素 [attr!=val] 选取attr的值不为val的元素 [attr^=val] 选取attr的值以val开始的元素 [attr$=val] 选取attr的值以val结束的元素 [attr*=val] 选取attr的值包含val的元素 [attr|=val] 选取attr的值为val或以val-开始的元素 [attr~=val] 选取attr的值包含&#39; val&#39;的元素（注意val前面要有空格） [attr1][attr2][attrN] 选取同时满足几个条件的元素，如$(&#39;div[id][title$=&quot;test&quot;]&#39;)，选取拥有属性id，并且属性title以test结束的div元素 子元素过滤选择器 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个或者奇偶子元素 :first-child 选取每个父元素的第一个子元素，如$(&#39;ul li:first-child&#39;), 选择ul的第一个li元素 :last-child 选取每个父元素的子元素 :only-child 如果父控件一个子元素，那么匹配到，否则不被匹配。$(&#39;ul li:only-child&#39;)返回只有一个子元素且为li的li元素 表单对象属性过滤选择器 :enabled 选取所有可用元素。$(&#39;#form1 :enabled&#39;),选取id为form1的表单内的所有可用元素。 :disbaled 选取所有不可用元素。 :checked 选取所有被选中元素(单选框，复选框)。$(&#39;input:checked&#39;),选取所有被选中的input元素 :selected 选取所有被选中的选项元素（下拉列表）。$(&#39;select option:seleted&#39;) 表单选择器 :input 选取所有&amp;lt;input&gt;,&amp;lt;textarea&gt;,&amp;lt;select&gt;,&amp;lt;button&gt;元素。如$(&#39;#form1 :input&#39;) :text 选取所有单行文本框。 :password 选取所有密码框 :radio 选取所有单选框 :submit 选取所有提交按钮 :image 选取所有的图像按钮 :reset 选取所有的重置按钮 :button 选取所有的按钮 :file 选取所有的上川域 :hidden 选取所有不可见元素]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
